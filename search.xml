<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 2018面试高频算法]]></title>
    <url>%2F2019%2F08%2F17%2FLeetcode2018Interview%2F</url>
    <content type="text"><![CDATA[简单题开始之前136 只出现一次的数字https://leetcode-cn.com/problems/single-number/ 169 求众数https://leetcode-cn.com/problems/two-sum/solution/qiu-zhong-shu-by-leetcode-2/ 1int major = nums.length/2;//求众数的条件 方法一 暴力搜索法 不建议，时间复杂度O(n2),空间复杂度O(1) 1234567891011121314151617181920class Solution &#123; public int majorityElement(int[] nums) &#123; if(nums.length &lt;= 0)&#123; return -1; &#125; for(int i=0;i&lt;nums.length;i++)&#123; int count = 0;//注意初始化位置，每次检查完i位置的数后需要把count清0，重新计数 for(int j=0;j&lt;nums.length;j++)&#123;//count初始为0.所以仍从第一个位置开始 if(nums[j] == nums[i])&#123; count++; &#125; &#125; if(count &gt; nums.length/2)&#123; return nums[i]; &#125; &#125; return -1; &#125;&#125; 方法二 Map遍历法Map常用于计数方面的算法，要牢记其初始化和遍历方法 时间复杂度O(n),空间复杂度O(n) 123456789101112131415161718192021222324252627class Solution &#123; public int majorityElement(int[] nums) &#123; int major = nums.length/2; Map&lt;Integer,Integer&gt; map = numsMap(nums);//map初始化 if(nums.length&lt;=0) &#123; return -1; &#125; for(Integer num:map.keySet()) &#123;//Map遍历的方式之一 if(map.get(num)&gt;major) &#123; return num; &#125; &#125; return -1; &#125; public Map&lt;Integer,Integer&gt; numsMap(int[] nums)&#123;//map初始化方法 Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int num:nums) &#123; if(!map.containsKey(num)) &#123; map.put(num, 1); &#125;else &#123; map.put(num, map.get(num)+1); &#125; &#125; return map; &#125;&#125; 方法三 Boyer-Moore 投票算法想法: 如果我们把众数记为 +1 ，把其他数记为 -1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。 （竖线用来划分每次计数器归零的情况）[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7] 首先，下标为 0 的 7 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 5 是下一个众数的候选者。由于这个例子中 7 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， 7 仍然是剩下数字中的众数。 123456789101112//计数法，相同就+1；不同就-1 public static int majorEle2(int[] nums) &#123; int count = 0; int candidate = nums[0]; for(int num:nums) &#123; if(count == 0) &#123; candidate = num; &#125; count += (candidate == num)? 1:-1; &#125; return candidate; &#125; 88. 合并两个有序数组https://leetcode-cn.com/problems/merge-sorted-array/给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 此处考虑到若从前往后 比较并排序需要把后面的数字挪动，为避免挪动增大空间复杂度，从后往前比较并填充 123456789101112131415161718class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p = m+n-1;//合并后的最大下标 m--;//最大下标 n--; while(n&gt;=0) &#123; if(m&gt;=0 &amp;&amp; nums1[m]&gt;nums2[n]) &#123;//注意判断次序， 需要先判断m再判断数组 nums1[p] = nums1[m]; m--; p--; &#125;else &#123; nums1[p] = nums2[n]; n--; p--; &#125; &#125; &#125;&#125; 简化后 123456public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p = m-- + --n; while(n&gt;=0)&#123; nums1[p--] = m&gt;=0 &amp;&amp; nums1[m]&gt;nums2[n] ? nums1[m--]:nums2[n--]; &#125;&#125; 字符串125. 验证回文串https://leetcode-cn.com/problems/valid-palindrome/ 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 双指针，一个从头开始，一个从尾开始 要求不区分大小写，就可以把字符串转为小写一定要区分好if和while 1234567891011121314151617181920212223242526272829303132public static boolean isPalindrome(String s) &#123; if (s == null) &#123; return true; &#125; s = s.toLowerCase();// 都转为小写 int i = 0, j = s.length() - 1; while (i &lt; j) &#123; while (!isLawful(s.charAt(i))) &#123; i++; if (i == s.length()) return true;// 空字符串 &#125; while (!isLawful(s.charAt(j))) &#123; j--; &#125; //char ichar = s.charAt(i);//debug用 //char jchar = s.charAt(j); if (s.charAt(i) != s.charAt(j)) return false; i++; j--; &#125; return true;&#125;private static boolean isLawful(char c) &#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9' || c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; return true; &#125; else &#123; return false; &#125;&#125; 387. 字符串中的第一个唯一字符https://leetcode-cn.com/problems/first-unique-character-in-a-string/给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: 12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 方法一 Map存储遍历和出现次数有关的，不要犹豫，hash 此类技术方法均可用map记录出现次数并遍历的方法。本题中不同点在于遍历时使用原先数组的索引进行遍历，因为题目要求的是找到第一个不重复的字符(value=1的key) 123456789101112131415public int firstUniqChar(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); char[] chars = s.toCharArray(); for(char ch:chars) &#123; if(map.containsKey(ch)) &#123; map.put(ch,map.get(ch)+1); &#125;else &#123; map.put(ch,1); &#125; &#125; for(int i=0;i&lt;s.length();i++) &#123; if(map.get(chars[i]) == 1) return i;//利用字符 串索引 &#125; return -1;&#125; 方法二 桶存储当全是字母字符时，可以考虑用大小为26的整型数组存储每个字母的频次，索引为ch-&#39;a&#39;, 相当于一个简化的Map，原理与Map存储相同 此处还应注意数组初始化大小之后，整型默认值均为0 12345678910public int firstUniqChar(String s) &#123; int[] freq = new int[26];//初始化数组后默认值均为0,值为频次，索引为ch-'a' for(int i=0;i&lt;s.length();i++) &#123; freq[s.charAt(i)-'a']++; &#125; for(int i=0;i&lt;s.length();i++) &#123; if(freq[s.charAt(i)-'a']==1) return i; &#125; return -1;&#125; 344. 反转字符串https://leetcode-cn.com/problems/reverse-string/编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 两个指针自增自减，相遇退出就完事了 12345678public void reverseString(char[] s) &#123; int i=0,j=s.length-1; while(j&gt;i) &#123; char temp = s[i]; s[i++] = s[j]; s[j--] = temp; &#125;&#125; 数组189. 旋转数组https://leetcode-cn.com/problems/rotate-array/ 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。要求使用空间复杂度为 O(1)的原地算法。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 方法一 暴力法理清旋转一次的算法，再重复k次即可。时间复杂度：O(n∗k) 。每个元素都被移动 1 步O(n)） k次O(k) 注意在变换时每次都是第j位和第 j-1 位的数值进行交换，并不是直接交换数值中的值，所以此处选取了prev来存储第j-1位的数值。 1234567891011121314151617181920class Solution &#123; public void rotate(int[] nums, int k) &#123; for(int i=0;i&lt;k;i++) &#123; /** * 每次循环变换一次,共变换k次 */ rotOnce(nums); &#125; &#125; public void rotOnce(int[] nums) &#123; int prev = nums[nums.length-1];//选取一个哨兵变量用于交换 for(int j=0;j&lt;nums.length;j++) &#123;//每次都是第j位和第j+1位的数值进行交换，j递增 int temp = nums[j]; nums[j] = prev; prev = temp;//prev每次都是nums[j]的前一个数值 &#125; &#125;&#125; 方法二 环状替换未看 217. 存在重复元素https://leetcode-cn.com/problems/contains-duplicate/给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 方法一 Map存储法刚开始想用数组桶的方法来存储每个数字出现的频次，但这种方法就忽略了负数的情况，造成了数组越界，故仍要用map 12345678910111213/***考虑不足的代码，弃用*/public boolean containsDuplicate(int[] nums) &#123; int[] freq = new int[10];//没有考虑负数的情况 for(int i=0;i&lt;nums.length;i++) &#123; freq[nums[i]]++; &#125; for(int f:freq) &#123; if(f&gt;1) return true; &#125; return false;&#125; AC代码如下,也是常规map，和出现次数有关 1234567891011121314151617class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int num:nums) &#123; if(map.containsKey(num)) &#123; map.put(num,map.get(num)+1); &#125;else &#123; map.put(num, 1); &#125; &#125; for(Integer num:map.keySet()) &#123; if(map.get(num)&gt;1) return true; &#125; return false; &#125;&#125; Boolean数组法没看懂TODO 283. 移动零(TODO)https://leetcode-cn.com/problems/move-zeroes/给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组 参考别人的方法 12345678910111213141516171819//思路：设置一个index，表示非0数的个数，循环遍历数组，// 如果不是0，将非0值移动到第index位置,然后index + 1//遍历结束之后，index值表示为非0的个数，再次遍历，从index位置后的位置此时都应该为0public void moveZeroes(int[] nums) &#123; if (nums == null || nums.length &lt;= 1) &#123; return; &#125; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[index] = nums[i]; index++; &#125; &#125; for (int i = index; i &lt; nums.length; i++) &#123; nums[i] = 0; &#125;&#125; 最后补零的操作其实可以替代为 直接交换nums[index]和nums[i]，因为index所经过的数组值都是非零项。如果是0，则index没有变，直接把i+1的非0值替换过来即可。 代码如下 12345678910111213public void moveZeroes(int[] nums) &#123; int index = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i]!=0) &#123; int temp = nums[index]; nums[index] = nums[i]; nums[i] = temp; index++; &#125; &#125;&#125; 堆、栈、队列链表哈希与映射树排序与搜索动态规划图论数学、位运算中等题数组堆、栈、队列链表哈希与映射树排序与搜索动态规划图论数学、位运算]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TODO:正则表达式，字符串拼接性能，设计购物车，KMP]]></title>
    <url>%2F2019%2F08%2F16%2FTODO%2F</url>
    <content type="text"><![CDATA[正则表达式字符串拼接性能https://blog.csdn.net/KimSoft/article/details/3353849https://blog.csdn.net/flashdelover/article/details/50249701 KMPHashMap内部结构，调用put方法时如何实现HashSet是如何保证元素不重复的MySQL中插入一千万条数据如何是实现String，StringBuffer，StringBuilder数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？hashCode与equals迭代器HashMap, HashTable, ConcurrentHashMap线程池JVM有三个比较容易混淆的概念： Java内存模型（Java Memory Model（JMM））JVM内存结构（JVM内存分区）Java对象结构 GCNIO，AIO，多路复用三次握手，四次挥手死锁与解锁]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏掉的筷子长度(只出现一次的数字)]]></title>
    <url>%2F2019%2F08%2F16%2FHuawei%2F</url>
    <content type="text"><![CDATA[昨天华为的一面题目，没想到竟然挂在了一个这么简单的题目上： 小明是个马大哈，某天他到超市买了若干双筷子（n &lt; 20），筷子的长度不尽相同，他把全部筷子都放在购物袋里面拿回家，路上不小心漏了一根，请你用程序帮他找出是漏掉的筷子是多长的。 题目看了半天，搞不懂输入输出应该是什么，问面试官输入只是一个n吗，回答说对的，你可以自己给筷子编号（wtf ？？）， 硬着头皮用n新建了一个空数组，然后暴力循环了两遍找里面单个的值。做完后心里想，既然已经知道了数组中每个筷子的长度，那我不就已经知道是掉了拿一根了嘛（真是想太多。。）面试官看了后说我的时间 复杂度太大，可以考虑换个数据结构。然后我就想到了键值对的Map， 面试官说你照着这个思路写一下，继续做的时候又陷入了怎么初始化数据的怪圈。。。 总体来说面试体验很差，一是题目没有明确输入与输出应该是什么，最起码有个案例也行啊。二是我经验不足，思考不够全面，被一道题卡在输入和数据初始化上不知道是我的问题还是我的问题，哎不说了，解题！ 今天一起实习的小伙伴告诉我说其实就是类似找重复或者不重复的数，异或就可以实现。上网找了一下题目，果然有明确的输入和输出(我哭了，有这两句话我早就写出来了。。。)： 输入： 剩下的筷子数组，如：1, 2, 3, 2, 1, 3, 2返回值：漏掉的筷子长度，如上述输入返回：2（当输入的筷子数据异常时返回-1，如：找不到漏掉的筷子） 暴力法也就是我在面试的时候答出来的，循环两遍查找有无重复的值，若有重复值，则跳出小循环，判断下一个数是否在后面的数里面有重复。方法过于笨拙，就不贴代码了吧。嵌套循环，时间复杂度为O(n2) 异或法先说一下异或的主要性质，在去重和找重方面经常应用： 0 ^ a = a;a ^ a = 0;去重：把所有的 下面是我写的代码，迭代器一次循环，时间复杂度为O(n)： 1234567891011121314public static int find1(int[] chopsticks) &#123; if(chopsticks.length &gt;=39) return -1; int result = 0; for(int chopLen:chopsticks) &#123; result ^= chopLen; &#125; return result;&#125;//测试public static void main(String[] args) &#123; int[] chopsticks = &#123;1,2,2,3,1,3,4&#125;; System.out.println(find1(chopsticks));&#125; 输出结果为4 Map遍历法考虑面试官提示的key-value存储形式，当时卡在了map初始化上，还得多加练习 123456789101112131415161718192021222324252627/** * Map解法 */public static int find2(int[] chopsticks) &#123; //Key为筷子长度，Value为个数 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();//初始化map，昨天也在这里卡住了 for(int i:chopsticks) &#123; if(map.containsKey(i)) &#123; map.put(i, map.get(i)+1);//有重复则数值+1 &#125; else &#123; map.put(i, 1); &#125; &#125; //遍历map，重点掌握 for(Integer i:map.keySet()) &#123; if(map.get(i) == 1) &#123; return i; &#125; &#125; return -1;&#125;//测试public static void main(String[] args) &#123; int[] chopsticks = &#123;1,2,2,3,1,3,4&#125;; System.out.println(find1(chopsticks));&#125; 输出结果为4 遍历Map的几种方法代码过程中发现忘记了怎么遍历map。。。赶紧复习一波参考博客https://www.cnblogs.com/bingyimeiling/p/10741761.html 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; // 循环遍历Map的4中方法 Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(1, 2); // 1. entrySet遍历，在键和值都需要时使用（最常用） for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println("key = " + entry.getKey() + ", value = " + entry.getValue()); &#125; // 2. 通过keySet或values来实现遍历,性能略低于第一种方式 // 遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println("key = " + key); &#125; // 遍历map中的值 for (Integer value : map.values()) &#123; System.out.println("key = " + value); &#125; // 3. 使用Iterator遍历 Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = it.next(); System.out.println("key = " + entry.getKey() + ", value = " + entry.getValue()); &#125; // 4. java8 Lambda // java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value， // 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key, value) -&gt; &#123; System.out.println(key + ":" + value); &#125;);&#125; 如果只是获取key，或者value，推荐使用keySet或者values方式； 如果同时需要key和value推荐使用entrySet； 如果需要在遍历过程中删除元素推荐使用Iterator； 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F08%2F15%2FSort%2F</url>
    <content type="text"><![CDATA[快速排序1234567891011121314151617181920212223242526272829/** * 快速排序 */public static void quickSort(int[] L, int low, int high) &#123; int pivot;//枢纽，左边的值都比它小，右边的值都比它大,是下标 if(low&lt;high) &#123; pivot = partition(L,low,high);//算出pivot，将L[low]...L[high]一分为二 quickSort(L, low, pivot-1);//低子表排序 quickSort(L, pivot+1, high);//高子表排序 &#125;&#125;public static int partition(int[] L,int low,int high) &#123; int key = L[low];//将数组的第一个记录作为pivot while(low&lt;high) &#123; while(low&lt;high &amp;&amp; L[high]&gt;key) &#123;//右边大，不交换，high-1下一个high high--; &#125; int temp1 = L[high]; L[high] = L[low]; L[low] = temp1;//右边比key小，则交换 while(low&lt;high &amp;&amp; L[low]&lt;key) &#123;//左边小，不交换，low++下一个low low++; &#125; int temp2 = L[high]; L[high] = L[low]; L[low] = temp2;//左边比key大，则交换 &#125; return low;&#125; 插入排序12345678910111213141516171819/** * 插入排序 */public static void insertSort(int[] L) &#123; for (int i = 1; i &lt; L.length; i++) &#123; if (L[i] &lt; L[i - 1]) &#123;// 在L[0]...L[i-1]的有序数列中找到合适的位置插入L[i] int temp = L[i];// 哨兵保存L[i]的值 int j; for (j = i-1; j&gt;=0 &amp;&amp; L[j]&gt;temp; j--) &#123; L[j + 1] = L[j];// 记录后移,把比a[i]大的数据向后移动 &#125; L[j + 1] = temp; &#125; &#125;&#125; 选择排序1234567891011121314151617181920/** * 选择排序 * @param L */public static void selectSort(int[] L) &#123; for(int i=0;i&lt;L.length;i++) &#123; int min = i;//初始为同一位置，如果i+1比i大则min仍然为i.循环进入i+1，min也为i+1 for(int j=i+1;j&lt;L.length;j++) &#123; if(L[j]&lt;L[min]) min = j;//找到i后面的数据的最小值，下标给min &#125; if(i!=min) &#123;//比较的是下标 int temp = L[i]; L[i] = L[min]; L[min] = temp; &#125; &#125;&#125; 冒泡排序优化冒泡排序1234567891011121314151617/** * 优化冒泡排序，对有序的数列不再进行判断，设置flag */public static void bubbleSort2(int[] L) &#123; boolean flag = true; for(int i=0;i&lt;L.length-1 &amp;&amp; flag;i++) &#123;//flag为false则说明没有发生交换，退出循环；若为true则说明发生了交换，仍需进一步判断排序 flag = false;//初始为false，没有数据交换 for(int j=L.length-1;j&gt;i;j--) &#123; if(L[j-1]&gt;L[j]) &#123;//交换 int temp = L[j]; L[j] = L[j-1]; L[j-1] = temp; flag = true; &#125; &#125; &#125;&#125; 单例模式多线程懒汉式1234567891011121314151617public class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(null == instance) &#123; synchronized(Singleton.class) &#123; if(null == instance) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; volatile 的必要性：new 对象的时候分为三个步骤,请求对象空间，对象初始化，指针指向对象。volatile保证了不发生指令重排，避免在if判断时，double check多线程出错]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP语法, EL, JSTL, JSON，Ajax辨析]]></title>
    <url>%2F2019%2F08%2F12%2Fjson-ajax-jstl-el%2F</url>
    <content type="text"><![CDATA[TODO前言对前端了解不多，在Web开发的学习中，时不时会遇到各种各样的前端语法的困扰，多种相似的表达式混用难免蛋疼。虽说已有各种框架解决了对这些前端脚本的解析，但本文旨在列举和梳理其中的知识体系，以免再混淆。 JSP语法与JSP脚本此处参考了博客https://segmentfault.com/a/1190000013152739#articleHeader5 JSP(Java Server Page), Java服务器界面，是一种特殊的简化的Servlet，主要特点是JSP中java代码可以和页面html代码组合使用。此处不细讲其工作原理和内容。本文主要关注其语法与脚本书写。 JSP初印象 在最简单的Web开发中，IDE初始生成的JSP页面index.jsp,再页面中使用Java输出Hello World如下： 123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ISO-8859-1"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%String s = "HelloWorld";//此处为Java代码out.println(s);%&gt;&lt;/body&gt;&lt;/html&gt; JSP语法 从上面代码看到，JSP中包含了HTML代码和Java代码 JSP脚本JSP中的Java代码就是JSP脚本，必须有&lt;% %&gt;括起来，否则jsp会将其解析为HTML代码，出现解析偏差或出错。 1234&lt;%String s = "HelloWorld";//此处为Java代码out.println(s);%&gt; JSP内容输出表达式&lt;%= %&gt; 用于在JSP中输出一个Java变量 12345678910....&lt;body&gt;&lt;%User user = (User) session.getAttribute("user");//jsp的session内置对象%&gt;用户名&lt;%=user.getUsername() %&gt;&lt;br/&gt;年龄&lt;%=user.getAge() %&gt;&lt;br/&gt;性别&lt;%=user.getGender() %&gt;&lt;br/&gt;&lt;/body&gt;.... JSP内容定义表达式&lt;%! %&gt; JSP定义表达式，用于成员变量的定义，在Java代码块里的是局部变量。但已经没人用了 JSP注释&lt;%-- --%&gt; 不起任何实际作用 还可以注释 &lt;% %&gt; 在java代码中依然可以使用java支持的注释: 1234///***/ JSP指令JSP用于声明JSP页面的相关属性，语法为 1&lt;%@指令 属性名="值" %&gt; 如在JSP初印象中，制定了JSP的语言，文档类型，编码类型 12&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; JSP指令还可用于在jsp中引入java类 12&lt;%@page import="java.util.Random"%&gt;&lt;%@page import="java.util.Random,java.text.*"%&gt; EL表达式EL（Expression Language）表达式语言，是为了使JSP写起来更加简单。不属于编程语言。用于查找作用域中的数据，然后对它们执行一些简单的操作，用于对jsp标签的属性赋值 在MVC模式中, JSP只充当视图，视图的任务就是显示响应，不需要在JSP中做任何关于程序控制和业务逻辑的事情。所以在JSP页面中应该尽可能少的、或者是完全不出现Java代码。来自百度百科 EL能干什么可以从域对象（request, session, application, pageContext等）中取得数据。 无需导包，可直接在JSP中使用。 EL表达式语法结构123456$&#123;expression&#125;$&#123;requestScope.key&#125;$&#123;pageContextScope.key&#125;$&#123;sessionScope.key&#125;$&#123;applicationScope.key&#125;$&#123;key&#125; &lt;%--如果不指定域，那么会依次从域中搜索--%&gt; EL举例123456789$&#123;username&#125; 取得request里面名字为username的属性值（如果不存在返回空字符串）$&#123;user.username&#125;$&#123;list[index]&#125;$&#123;map.key&#125;$&#123;pageContext.request.contextPath&#125;$&#123;10+89&#125; 支持放置表达式运算$&#123;age&gt;10&#125;$&#123;empty user&#125; 是否是null对象 运算符号最好在{}内部实现，比如${a.count*b.price},而不能写成${a.count}*${b.price} JSTL此处参考了博客https://blog.csdn.net/qq_42350238/article/details/88994988 JSTL（JavaServer Pages Standard Tag Library，JSP标准标签库)是一个不断完善的开源的JSP标签库,通常与EL表达式合作实现JSP页面的编写，让JSP写起来更加简单，优雅。可以让JSP页面在不写java代码的情况下实现取数据。 jstl是一个标签库，什么是标签库？可以只用一些自定义有自定义功能的标签。 其实EL+JSTL标签比java代码好用，就前端来说，而且它可以直接操作json类型，完美适应。 JSTL的引入下载地址 http://tomcat.apache.org/taglibs/standard/ 要使用jstl提供的标签，要先引入JSTL对应的标签库taglib 如何引入jstl标签库：(利用JSP指令的语法) 12&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt; 就可以引入对应想要的标签库，其中 uri：JSP标签的命名空间 prefix：命名空间的前缀(简称) JSTL的使用(常用标签举例)跟数据存储相关： set, out, remove123456789101112&lt;c:set var="username" value="123" scope="request"&gt;&lt;/c:set&gt;&lt;%//request.setAttribute("username", "123");%&gt;&lt;c:out value="$&#123;username &#125;"&gt;&lt;/c:out&gt;$&#123;username&#125;&lt;c:remove var="username" scope="request" /&gt;&lt;%//request.removeAttribute("username");%&gt; 条件标签if 语句 123&lt;c:if test="$&#123;age&gt;=19 &#125;"&gt;&lt;font color="green"&gt;你是成年人&lt;/font&gt;&lt;/c:if&gt; if else 语句 12345678&lt;c:choose&gt;&lt;c:when test="$&#123;age&gt;=19 &#125;"&gt;&lt;font color="green"&gt;你是成年人&lt;/font&gt;&lt;/c:when&gt;&lt;c:otherwise&gt;&lt;font color="red"&gt;未成年&lt;/font&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签1234567&lt;c:forEach items="$&#123;lists &#125;" var="user"&gt;$&#123;user.username &#125;:$&#123;user.age &#125;&lt;br/&gt;&lt;/c:forEach&gt;&lt;c:forEach items="$&#123;map &#125;" var="kv"&gt;$&#123;kv.key &#125;:$&#123;kv.value &#125;&lt;br/&gt;&lt;/c:forEach&gt;（要给属性提供get方法） JSONJSON (JavaScript Object Notation, JS对象表达) 是一种轻量级的数据交换格式,采用完全独立于编程语言的文本格式来存储和表示数据. 详细介绍可参考http://www.json.org/json-zh.html JSON只用于存储可被解析的数据，其本质是一个字符串 JSON出现之前，通常用XML来传递数据。XML也是一种纯文本格式，所以它适合在网络上交换数据，但由于XML规范繁琐复杂， 格式非常简单，有两种结构。 JSON两种结构对象对象结构以{大括号开始，以}大括号结束。内部由多个键值对构成，键值对之间由,分隔: 1234567891011121314&#123; "name": "小明", "age": 14, "gender": true, "height": 1.65, "grade": null, "middle-school": "\"W3C\" Middle School", "skills": [ "JavaScript", "Java", "Python", "Lisp" ]&#125; 相当于一个JavaBean，对象中包含了一个 数组数组类型可以是对象类型，即元素是对象。由方括号[ ]规定。 12345678910[ &#123; "name": "小明", "age": 14, &#125;, &#123; "name": "小华", "age": 22, &#125;] JSON注意事项 JSON规定字符集必须是UTF-8。 为了统一解析，JSON的字符串规定必须用双引号&quot;&quot;，Object的键也必须用双引号&quot;&quot;。 此处参考了廖雪峰的官方网站对JS的讲解 JSON字符串与JSON对象辨析 字符串：指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’; json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”; json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” }; 此处参考了mcgrady的博客 AjaxAjax, 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 最常用的应用就是在前端注册信息时，不刷新网页的情况下校验是否存在重复的用户名，或者校验输入的邮箱格式是否正确。 作用：在不进行页面跳转或者页面刷新的情况下，向服务器发起请求，并取得服务器响应的数据。 应用领域：数据校验 优点： ①用户体验比较好(不需要页面跳转，速度快) ②服务器压力比较小 jQuery发起Ajax请求123456789101112$.ajax(&#123; url:"xxxservlet", type:"post", data:&#123; key:value, key:value &#125;, dataType:"json", success:function(msg)&#123; msg.key; &#125;&#125;); 其他参数和用法http://api.jquery.com/jQuery.ajax/ JavaScript发起Ajax请求12345678var xmlhttp = new XMLHttpRequest();xmlhttp.open("GET","xxxservlet",true);xmlhttp.send();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; //成功后的处理 &#125;&#125; 其他参数和用法http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>Web</tag>
        <tag>EL</tag>
        <tag>JSTL</tag>
        <tag>Ajax</tag>
        <tag>JSON</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Database做题笔记]]></title>
    <url>%2F2019%2F08%2F05%2FLeetcode-Database%2F</url>
    <content type="text"><![CDATA[TODO 不连接交叉连接(即用,在from中分隔两表)和内连接的区别，是不是都可以产生笛卡尔积？ 连接时用的on和判断时用的where如何正确使用，同时使用时如何正确使用？详见183方法一 使用group by时，只要是select中非聚集函数的列，都要在 group by当中 NOTE1. 交叉连接与隐式内连接的区别个人理解是，没有where就是交叉连接，有where就是隐式内连接。产生的中间表均为笛卡尔积，区别在于隐式内连接会对产生的笛卡尔积通过where进行过滤得到结果。 12SELECT * FROM 表1 CROSS JOIN 表2; --交叉连接SELECT * FROM 表1，表2 隐式内连接不用on语句，而用where 1SELECT * FROM 表1,表2 where 表1.关系字段 = 表2.关系字段 --隐式内连接 2. on, where, having的正确使用此处参考了古月慕南和LYQ1990的博客，个人理解是 on用于建立关联关系, where用于筛选关联关系。 on是用于生成临时表时使用的条件。在外连接中，不管on的条件是否为真，都会返回left join中的左表信息，或者right join中的右表信息。 where是在临时表生成之后对该临时表过滤用的条件，过滤掉条件不为真的所有信息。 在内连接中，条件放在on和where没区别，返回的结果集是相同的。 在优先级方面，on &gt; where &gt; 聚合函数 &gt; having: 表关联生成临时表， on 条件生效（此时的临时表会因为left join或right join的特性而一定带有主表的记录，也就是主表的记录不会被 on 条件过滤掉） –&gt; 临时表生成完毕，where条件过滤临时表（where条件过滤时因为临时表已经生成完毕，因此不会再具有left join或right join的特性，也就是主表记录也会被where条件过滤掉） –&gt; 临时表过滤完毕，聚合函数进行运算 –&gt; 聚合函数运算完毕，having生效对运算完毕的临时表进行过滤 –&gt;最终的结果表 原文链接：https://blog.csdn.net/qq_27607579/article/details/83787592 having只与group by 连用， 即在分组过后过滤数据，条件中通常包含聚合函数。 ① WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。② GROUP BY 子句用来分组 WHERE 子句的输出。③ HAVING 子句用来从分组的结果中筛选行。 181. Employees Earning More Than Their Managers来源：https://leetcode.com/problems/employees-earning-more-than-their-managers/description/考察：同一个表内的信息对比，需要把一张表看作两张表分别对比条件进行查询，也就是从这个表里获取两次信息。可以用到内连接，也可以不用内连接直接查询。 DescriptionEmployee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 12345+----------+| Employee |+----------+| Joe |+----------+ Solution此处还要注意题目还要求最终输出结果的表头为Employee 方法一：12345select e1.Name as Employee --更改字段名,as可缺省from Employee e1, Employee e2where e1.ManagerId = e2.Idand e1.Salary &gt; e2.Salary;--用时461 ms 在where语句之前，可以理解为交叉连接产生笛卡尔积，查询结果有4×4=16个。一般情况下不会使用交叉连接，这这业务需求比较少见。在有where语句时，语句表示一个隐性内连接，产生的中间表仍为笛卡尔积，结果用where语句过滤掉 方法二：内连接12345select e1.Name as Employeefrom Employee e1 inner join Employee e2--inner可缺省on e1.ManagerId = e2.Idand e1.Salary &gt; e2.Salary;--615 ms 方法三：子查询123456select e1.Name as Employeefrom Employee e1where Salary &gt; (select Salary from Employee e2 where e2.Id = e1.ManagerId);--974 ms 183. Customers Who Never Order来源：https://leetcode.com/problems/customers-who-never-order/description/考察：查找不存在的数据，连接用is null,子查询用not in Description某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： 12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表： 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回： 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ Solution方法一：左外连接要查询Orders表中不存在，但在Customers表中存在的CustomerId,把Orders放在左连接的右边，就可以查询出Orders中CustomerId为null的数据 1234select c.Name as Customersfrom Customers c left join Orders oon c.Id = o.CustomerIdwhere o.CustomerId is null; 方法二：子查询查询不存在的值，可以用where与not in结合的方法，利用子查询 123select Name as Customersfrom Customerswhere Id not in (select CustomerId from Orders) 184. Department Highest Salary来源：https://leetcode.com/problems/department-highest-salary/description/考察：使用join和in。in可以用于多个字段,子查询或临时表 DescriptionEmployee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ Solution首先可以在Employee表中根据DepartmentId分组找到每组最高Salary所代表的信息，也就是先创建一个临时表，包含了部门员工的最大薪资：此处特别注意: select中非聚集函数的列，都要在 group by 中 123select DepartmentId, max(Salary)from Employeegroup by DepartmentId 得出结果为 1234| DepartmentId | MAX(Salary) ||--------------|-------------|| 1 | 90000 || 2 | 80000 | 然后，把表 Employee 和 Department 连接，再在这张临时表里用 IN语句查询部门名字和工资的关系。在in语句中可以同时使用多个字段 12345select d.Name Department, e.Name Employee, Salaryfrom Department d join Employee e on d.Id = e.DepartmentIdwhere (e.DepartmentId, Salary) in ( select DepartmentId, max(Salary) from Employee group by DepartmentId );]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>笔试</tag>
        <tag>LeetCode</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔试题常用输入方法]]></title>
    <url>%2F2019%2F07%2F30%2Fscanner_input%2F</url>
    <content type="text"><![CDATA[从三月份找实习开始，我才算是真正意识到自己有多菜。经历了数不清多少次的笔试，算法方面菜鸡也就算了，没想到几乎每次考试都会在输入方面卡壳半个小时左右。这次7.28号拼多多“学霸批”的笔试，也是在输入方面浪费了大量时间。为此，在这里总结一下笔试可能会用到的输入方法，吃一堑长一智。本文持续更新。 类型一：多行输入，每行为一个数组，数字之间用空格隔开 1234567891011121314151617Scanner in = new Scanner(System.in);String str1 = in.nextLine().toString();//读取第一行String[] a = str1.split(" ");//按空格分开为字符串数组int[] arrA = new int[a.length];//新建同大小的整型数组for (int i = 0; i &lt; arrA.length; i++) &#123; arrA[i] = Integer.parseInt(a[i]);//字符串解析为十进制整数&#125;String str2 = in.nextLine().toString();//读取第二行，后面几行同理String[] b = str2.split(" ");int[] arrB = new int[b.length];for (int i = 0; i &lt; arrB.length; i++) &#123; arrB[i] = Integer.parseInt(b[i]);&#125;System.out.println(Arrays.toString(arrA));//显示数组System.out.println(Arrays.toString(arrB)); 类型二：第一行一个整数，第二行一个数组此类型的输入不区分各行，只判定第一个整数为数组大小，之后的整数为数组数据即可。也就是只按整型输入读取。 1234567891011121314151617 /** * 输入一个整数(数组大小)，一个数组(空格或回车隔开) * 2 * 1 3 * @author YJC * */Scanner in = new Scanner(System.in);while(in.hasNext()) &#123; int m = in.nextInt();//读取第一个整数，即数组大小 int[] numbers = new int[m];//新建数组 for(int i=0;i&lt;m;i++) &#123; numbers[i] = in.nextInt();//按整型输入读取 &#125; System.out.println(Arrays.toString(numbers));&#125; 类型三：输入多行整数用逗号隔开 输入 120,3,55 代码如下 12345Scanner in = new Scanner(System.in);String[] line = in.nextLine().split(",");int a = Integer.parseInt(line[0]);int b = Integer.parseInt(line[1]);int c = Integer.parseInt(line[2]);]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>输入</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现单链表，实现链表的插入和删除]]></title>
    <url>%2F2019%2F07%2F30%2FlinkedList%2F</url>
    <content type="text"><![CDATA[创建自定义的类和构造方法来实现简单的单链表。将结点结构定义为私有内部类，在外部类中对链表结构进行初始化，包括头结点和初始大小。 单链表操作原理不难，难点在于对链表进行插入和删除操作时，对于指针交换和分配的逻辑。 插入：找到要插入的位置 i 后，用新结点的后继指针替换 i 的后继指针，再将 i 的后继指针指向该新结点。 删除：将要删除位置的后继指针指向下下个元素。 整表创建：注意头插法和尾插法的逻辑，详见代码注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package SqList;/** * 单链表 * @author YJC * */public class SingleLinkedList &#123; //定义链表 private int size;//链表节点的个数 private Node head;//头节点 public SingleLinkedList() &#123; size = 0; head = null; &#125; //链表的结点类 private class Node&#123; private Object data;//每个节点的数据 private Node next;//结点指向下一个节点的指针 public Node(Object data) &#123; this.data = data; &#125; &#125; //查找链表中第i个元素,返回给e public Node find(int i,Object e) &#123; Node current = head; int temp = 1; while(temp&lt;i) &#123; current = current.next; temp++; &#125; e = current; return (Node) e; &#125; //在第i个位置前插入新的元素e public Object insert(int i,Object e) &#123; Node newNode = new Node(e);//新建一个节点 Node current = head; int temp = 1; while(temp&lt;i) &#123; current = current.next; temp++; &#125; newNode.next = current.next; current.next = newNode; return newNode; &#125; //删除第i个结点 public void delete(int i) &#123; int temp = 1; Node current = head; while(temp&lt;i &amp;&amp; current!=null) &#123; current = current.next; temp++; &#125; current.next = current.next.next; &#125; //单链表的整表创建,头插法 加入n个元素到单链表 public void createAtHead(int n) &#123; Node head = null;//头结点指向null，即建立一个带头结点的单链表 for(int i=0;i&lt;n;i++) &#123; Node node = new Node(Math.random()*100+1);//生成1-100的数字 node.next = head; head = node; &#125; &#125; public void createAtTail(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; Node node = new Node(Math.random() * 100 + 1);// 生成1-100的数字 Node tempNode = head; while (null != tempNode.next) &#123; tempNode = tempNode.next;//寻找尾结点 &#125; //此时tempNode是尾结点 node.next = tempNode.next;//null，把node定义为尾结点，后继指针为null tempNode.next = node;//当前尾结点的后继指针指向node &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
