<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSP语法, EL, JSTL, JSON，Ajax辨析]]></title>
    <url>%2F2019%2F08%2F12%2Fjson-ajax-jstl-el%2F</url>
    <content type="text"><![CDATA[TODO前言对前端了解不多，在Web开发的学习中，时不时会遇到各种各样的前端语法的困扰，多种相似的表达式混用难免蛋疼。虽说已有各种框架解决了对这些前端脚本的解析，但本文旨在列举和梳理其中的知识体系，以免再混淆。 JSP语法与JSP脚本此处参考了博客https://segmentfault.com/a/1190000013152739#articleHeader5 JSP(Java Server Page), Java服务器界面，是一种特殊的简化的Servlet，主要特点是JSP中java代码可以和页面html代码组合使用。此处不细讲其工作原理和内容。本文主要关注其语法与脚本书写。 JSP初印象 在最简单的Web开发中，IDE初始生成的JSP页面index.jsp,再页面中使用Java输出Hello World如下： 123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ISO-8859-1"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%String s = "HelloWorld";//此处为Java代码out.println(s);%&gt;&lt;/body&gt;&lt;/html&gt; JSP语法 从上面代码看到，JSP中包含了HTML代码和Java代码 JSP脚本JSP中的Java代码就是JSP脚本，必须有&lt;% %&gt;括起来，否则jsp会将其解析为HTML代码，出现解析偏差或出错。 1234&lt;%String s = "HelloWorld";//此处为Java代码out.println(s);%&gt; JSP内容输出表达式&lt;%= %&gt; 用于在JSP中输出一个Java变量 12345678910....&lt;body&gt;&lt;%User user = (User) session.getAttribute("user");//jsp的session内置对象%&gt;用户名&lt;%=user.getUsername() %&gt;&lt;br/&gt;年龄&lt;%=user.getAge() %&gt;&lt;br/&gt;性别&lt;%=user.getGender() %&gt;&lt;br/&gt;&lt;/body&gt;.... JSP内容定义表达式&lt;%! %&gt; JSP定义表达式，用于成员变量的定义，在Java代码块里的是局部变量。但已经没人用了 JSP注释&lt;%-- --%&gt; 不起任何实际作用 还可以注释 &lt;% %&gt; 在java代码中依然可以使用java支持的注释: 1234///***/ JSP指令JSP用于声明JSP页面的相关属性，语法为 1&lt;%@指令 属性名="值" %&gt; 如在JSP初印象中，制定了JSP的语言，文档类型，编码类型 12&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; JSP指令还可用于在jsp中引入java类 12&lt;%@page import="java.util.Random"%&gt;&lt;%@page import="java.util.Random,java.text.*"%&gt; EL表达式EL（Expression Language）表达式语言，是为了使JSP写起来更加简单。不属于编程语言。用于查找作用域中的数据，然后对它们执行一些简单的操作，用于对jsp标签的属性赋值 在MVC模式中, JSP只充当视图，视图的任务就是显示响应，不需要在JSP中做任何关于程序控制和业务逻辑的事情。所以在JSP页面中应该尽可能少的、或者是完全不出现Java代码。来自百度百科 EL能干什么可以从域对象（request, session, application, pageContext等）中取得数据。 无需导包，可直接在JSP中使用。 EL表达式语法结构123456$&#123;expression&#125;$&#123;requestScope.key&#125;$&#123;pageContextScope.key&#125;$&#123;sessionScope.key&#125;$&#123;applicationScope.key&#125;$&#123;key&#125; &lt;%--如果不指定域，那么会依次从域中搜索--%&gt; EL举例123456789$&#123;username&#125; 取得request里面名字为username的属性值（如果不存在返回空字符串）$&#123;user.username&#125;$&#123;list[index]&#125;$&#123;map.key&#125;$&#123;pageContext.request.contextPath&#125;$&#123;10+89&#125; 支持放置表达式运算$&#123;age&gt;10&#125;$&#123;empty user&#125; 是否是null对象 运算符号最好在{}内部实现，比如${a.count*b.price},而不能写成${a.count}*${b.price} JSTL此处参考了博客https://blog.csdn.net/qq_42350238/article/details/88994988 JSTL（JavaServer Pages Standard Tag Library，JSP标准标签库)是一个不断完善的开源的JSP标签库,通常与EL表达式合作实现JSP页面的编写，让JSP写起来更加简单，优雅。可以让JSP页面在不写java代码的情况下实现取数据。 jstl是一个标签库，什么是标签库？可以只用一些自定义有自定义功能的标签。 其实EL+JSTL标签比java代码好用，就前端来说，而且它可以直接操作json类型，完美适应。 JSTL的引入下载地址 http://tomcat.apache.org/taglibs/standard/ 要使用jstl提供的标签，要先引入JSTL对应的标签库taglib 如何引入jstl标签库：(利用JSP指令的语法) 12&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt; 就可以引入对应想要的标签库，其中 uri：JSP标签的命名空间 prefix：命名空间的前缀(简称) JSTL的使用(常用标签举例)跟数据存储相关： set, out, remove123456789101112&lt;c:set var="username" value="123" scope="request"&gt;&lt;/c:set&gt;&lt;%//request.setAttribute("username", "123");%&gt;&lt;c:out value="$&#123;username &#125;"&gt;&lt;/c:out&gt;$&#123;username&#125;&lt;c:remove var="username" scope="request" /&gt;&lt;%//request.removeAttribute("username");%&gt; 条件标签if 语句 123&lt;c:if test="$&#123;age&gt;=19 &#125;"&gt;&lt;font color="green"&gt;你是成年人&lt;/font&gt;&lt;/c:if&gt; if else 语句 12345678&lt;c:choose&gt;&lt;c:when test="$&#123;age&gt;=19 &#125;"&gt;&lt;font color="green"&gt;你是成年人&lt;/font&gt;&lt;/c:when&gt;&lt;c:otherwise&gt;&lt;font color="red"&gt;未成年&lt;/font&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; 循环标签1234567&lt;c:forEach items="$&#123;lists &#125;" var="user"&gt;$&#123;user.username &#125;:$&#123;user.age &#125;&lt;br/&gt;&lt;/c:forEach&gt;&lt;c:forEach items="$&#123;map &#125;" var="kv"&gt;$&#123;kv.key &#125;:$&#123;kv.value &#125;&lt;br/&gt;&lt;/c:forEach&gt;（要给属性提供get方法） JSONJSON (JavaScript Object Notation, JS对象表达) 是一种轻量级的数据交换格式,采用完全独立于编程语言的文本格式来存储和表示数据. 详细介绍可参考http://www.json.org/json-zh.html JSON只用于存储可被解析的数据，其本质是一个字符串 JSON出现之前，通常用XML来传递数据。XML也是一种纯文本格式，所以它适合在网络上交换数据，但由于XML规范繁琐复杂， 格式非常简单，有两种结构。 JSON两种结构对象对象结构以{大括号开始，以}大括号结束。内部由多个键值对构成，键值对之间由,分隔: 1234567891011121314&#123; "name": "小明", "age": 14, "gender": true, "height": 1.65, "grade": null, "middle-school": "\"W3C\" Middle School", "skills": [ "JavaScript", "Java", "Python", "Lisp" ]&#125; 相当于一个JavaBean，对象中包含了一个 数组数组类型可以是对象类型，即元素是对象。由方括号[ ]规定。 12345678910[ &#123; "name": "小明", "age": 14, &#125;, &#123; "name": "小华", "age": 22, &#125;] JSON注意事项 JSON规定字符集必须是UTF-8。 为了统一解析，JSON的字符串规定必须用双引号&quot;&quot;，Object的键也必须用双引号&quot;&quot;。 此处参考了廖雪峰的官方网站对JS的讲解 JSON字符串与JSON对象辨析 字符串：指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’; json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”; json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” }; 此处参考了mcgrady的博客 AjaxAjax, 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 最常用的应用就是在前端注册信息时，不刷新网页的情况下校验是否存在重复的用户名，或者校验输入的邮箱格式是否正确。 作用：在不进行页面跳转或者页面刷新的情况下，向服务器发起请求，并取得服务器响应的数据。 应用领域：数据校验 优点： ①用户体验比较好(不需要页面跳转，速度快) ②服务器压力比较小 jQuery发起Ajax请求123456789101112$.ajax(&#123; url:"xxxservlet", type:"post", data:&#123; key:value, key:value &#125;, dataType:"json", success:function(msg)&#123; msg.key; &#125;&#125;); 其他参数和用法http://api.jquery.com/jQuery.ajax/ JavaScript发起Ajax请求12345678var xmlhttp = new XMLHttpRequest();xmlhttp.open("GET","xxxservlet",true);xmlhttp.send();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; //成功后的处理 &#125;&#125; 其他参数和用法http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>Web</tag>
        <tag>EL</tag>
        <tag>JSTL</tag>
        <tag>Ajax</tag>
        <tag>JSON</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Database做题笔记]]></title>
    <url>%2F2019%2F08%2F05%2FLeetcode-Database%2F</url>
    <content type="text"><![CDATA[TODO 不连接交叉连接(即用,在from中分隔两表)和内连接的区别，是不是都可以产生笛卡尔积？ 连接时用的on和判断时用的where如何正确使用，同时使用时如何正确使用？详见183方法一 使用group by时，只要是select中非聚集函数的列，都要在 group by当中 NOTE1. 交叉连接与隐式内连接的区别个人理解是，没有where就是交叉连接，有where就是隐式内连接。产生的中间表均为笛卡尔积，区别在于隐式内连接会对产生的笛卡尔积通过where进行过滤得到结果。 12SELECT * FROM 表1 CROSS JOIN 表2; --交叉连接SELECT * FROM 表1，表2 隐式内连接不用on语句，而用where 1SELECT * FROM 表1,表2 where 表1.关系字段 = 表2.关系字段 --隐式内连接 2. on, where, having的正确使用此处参考了古月慕南和LYQ1990的博客，个人理解是 on用于建立关联关系, where用于筛选关联关系。 on是用于生成临时表时使用的条件。在外连接中，不管on的条件是否为真，都会返回left join中的左表信息，或者right join中的右表信息。 where是在临时表生成之后对该临时表过滤用的条件，过滤掉条件不为真的所有信息。 在内连接中，条件放在on和where没区别，返回的结果集是相同的。 在优先级方面，on &gt; where &gt; 聚合函数 &gt; having: 表关联生成临时表， on 条件生效（此时的临时表会因为left join或right join的特性而一定带有主表的记录，也就是主表的记录不会被 on 条件过滤掉） –&gt; 临时表生成完毕，where条件过滤临时表（where条件过滤时因为临时表已经生成完毕，因此不会再具有left join或right join的特性，也就是主表记录也会被where条件过滤掉） –&gt; 临时表过滤完毕，聚合函数进行运算 –&gt; 聚合函数运算完毕，having生效对运算完毕的临时表进行过滤 –&gt;最终的结果表 原文链接：https://blog.csdn.net/qq_27607579/article/details/83787592 having只与group by 连用， 即在分组过后过滤数据，条件中通常包含聚合函数。 ① WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。② GROUP BY 子句用来分组 WHERE 子句的输出。③ HAVING 子句用来从分组的结果中筛选行。 181. Employees Earning More Than Their Managers来源：https://leetcode.com/problems/employees-earning-more-than-their-managers/description/考察：同一个表内的信息对比，需要把一张表看作两张表分别对比条件进行查询，也就是从这个表里获取两次信息。可以用到内连接，也可以不用内连接直接查询。 DescriptionEmployee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 12345+----------+| Employee |+----------+| Joe |+----------+ Solution此处还要注意题目还要求最终输出结果的表头为Employee 方法一：12345select e1.Name as Employee --更改字段名,as可缺省from Employee e1, Employee e2where e1.ManagerId = e2.Idand e1.Salary &gt; e2.Salary;--用时461 ms 在where语句之前，可以理解为交叉连接产生笛卡尔积，查询结果有4×4=16个。一般情况下不会使用交叉连接，这这业务需求比较少见。在有where语句时，语句表示一个隐性内连接，产生的中间表仍为笛卡尔积，结果用where语句过滤掉 方法二：内连接12345select e1.Name as Employeefrom Employee e1 inner join Employee e2--inner可缺省on e1.ManagerId = e2.Idand e1.Salary &gt; e2.Salary;--615 ms 方法三：子查询123456select e1.Name as Employeefrom Employee e1where Salary &gt; (select Salary from Employee e2 where e2.Id = e1.ManagerId);--974 ms 183. Customers Who Never Order来源：https://leetcode.com/problems/customers-who-never-order/description/考察：查找不存在的数据，连接用is null,子查询用not in Description某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： 12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表： 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回： 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ Solution方法一：左外连接要查询Orders表中不存在，但在Customers表中存在的CustomerId,把Orders放在左连接的右边，就可以查询出Orders中CustomerId为null的数据 1234select c.Name as Customersfrom Customers c left join Orders oon c.Id = o.CustomerIdwhere o.CustomerId is null; 方法二：子查询查询不存在的值，可以用where与not in结合的方法，利用子查询 123select Name as Customersfrom Customerswhere Id not in (select CustomerId from Orders) 184. Department Highest Salary来源：https://leetcode.com/problems/department-highest-salary/description/考察：使用join和in。in可以用于多个字段,子查询或临时表 DescriptionEmployee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ Solution首先可以在Employee表中根据DepartmentId分组找到每组最高Salary所代表的信息，也就是先创建一个临时表，包含了部门员工的最大薪资：此处特别注意: select中非聚集函数的列，都要在 group by 中 123select DepartmentId, max(Salary)from Employeegroup by DepartmentId 得出结果为 1234| DepartmentId | MAX(Salary) ||--------------|-------------|| 1 | 90000 || 2 | 80000 | 然后，把表 Employee 和 Department 连接，再在这张临时表里用 IN语句查询部门名字和工资的关系。在in语句中可以同时使用多个字段 12345select d.Name Department, e.Name Employee, Salaryfrom Department d join Employee e on d.Id = e.DepartmentIdwhere (e.DepartmentId, Salary) in ( select DepartmentId, max(Salary) from Employee group by DepartmentId );]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>MySQL</tag>
        <tag>面试</tag>
        <tag>数据库</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔试题常用输入方法]]></title>
    <url>%2F2019%2F07%2F30%2Fscanner_input%2F</url>
    <content type="text"><![CDATA[从三月份找实习开始，我才算是真正意识到自己有多菜。经历了数不清多少次的笔试，算法方面菜鸡也就算了，没想到几乎每次考试都会在输入方面卡壳半个小时左右。这次7.28号拼多多“学霸批”的笔试，也是在输入方面浪费了大量时间。为此，在这里总结一下笔试可能会用到的输入方法，吃一堑长一智。本文持续更新。 类型一：多行输入，每行为一个数组，数字之间用空格隔开 1234567891011121314151617Scanner in = new Scanner(System.in);String str1 = in.nextLine().toString();//读取第一行String[] a = str1.split(" ");//按空格分开为字符串数组int[] arrA = new int[a.length];//新建同大小的整型数组for (int i = 0; i &lt; arrA.length; i++) &#123; arrA[i] = Integer.parseInt(a[i]);//字符串解析为十进制整数&#125;String str2 = in.nextLine().toString();//读取第二行，后面几行同理String[] b = str2.split(" ");int[] arrB = new int[b.length];for (int i = 0; i &lt; arrB.length; i++) &#123; arrB[i] = Integer.parseInt(b[i]);&#125;System.out.println(Arrays.toString(arrA));//显示数组System.out.println(Arrays.toString(arrB)); 类型二：第一行一个整数，第二行一个数组此类型的输入不区分各行，只判定第一个整数为数组大小，之后的整数为数组数据即可。也就是只按整型输入读取。 1234567891011121314151617 /** * 输入一个整数(数组大小)，一个数组(空格或回车隔开) * 2 * 1 3 * @author YJC * */Scanner in = new Scanner(System.in);while(in.hasNext()) &#123; int m = in.nextInt();//读取第一个整数，即数组大小 int[] numbers = new int[m];//新建数组 for(int i=0;i&lt;m;i++) &#123; numbers[i] = in.nextInt();//按整型输入读取 &#125; System.out.println(Arrays.toString(numbers));&#125; 类型三：输入多行整数用逗号隔开 输入 120,3,55 代码如下 12345Scanner in = new Scanner(System.in);String[] line = in.nextLine().split(",");int a = Integer.parseInt(line[0]);int b = Integer.parseInt(line[1]);int c = Integer.parseInt(line[2]);]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>输入</tag>
        <tag>笔试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现单链表，实现链表的插入和删除]]></title>
    <url>%2F2019%2F07%2F30%2FlinkedList%2F</url>
    <content type="text"><![CDATA[创建自定义的类和构造方法来实现简单的单链表。将结点结构定义为私有内部类，在外部类中对链表结构进行初始化，包括头结点和初始大小。 单链表操作原理不难，难点在于对链表进行插入和删除操作时，对于指针交换和分配的逻辑。 插入：找到要插入的位置 i 后，用新结点的后继指针替换 i 的后继指针，再将 i 的后继指针指向该新结点。 删除：将要删除位置的后继指针指向下下个元素。 整表创建：注意头插法和尾插法的逻辑，详见代码注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package SqList;/** * 单链表 * @author YJC * */public class SingleLinkedList &#123; //定义链表 private int size;//链表节点的个数 private Node head;//头节点 public SingleLinkedList() &#123; size = 0; head = null; &#125; //链表的结点类 private class Node&#123; private Object data;//每个节点的数据 private Node next;//结点指向下一个节点的指针 public Node(Object data) &#123; this.data = data; &#125; &#125; //查找链表中第i个元素,返回给e public Node find(int i,Object e) &#123; Node current = head; int temp = 1; while(temp&lt;i) &#123; current = current.next; temp++; &#125; e = current; return (Node) e; &#125; //在第i个位置前插入新的元素e public Object insert(int i,Object e) &#123; Node newNode = new Node(e);//新建一个节点 Node current = head; int temp = 1; while(temp&lt;i) &#123; current = current.next; temp++; &#125; newNode.next = current.next; current.next = newNode; return newNode; &#125; //删除第i个结点 public void delete(int i) &#123; int temp = 1; Node current = head; while(temp&lt;i &amp;&amp; current!=null) &#123; current = current.next; temp++; &#125; current.next = current.next.next; &#125; //单链表的整表创建,头插法 加入n个元素到单链表 public void createAtHead(int n) &#123; Node head = null;//头结点指向null，即建立一个带头结点的单链表 for(int i=0;i&lt;n;i++) &#123; Node node = new Node(Math.random()*100+1);//生成1-100的数字 node.next = head; head = node; &#125; &#125; public void createAtTail(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; Node node = new Node(Math.random() * 100 + 1);// 生成1-100的数字 Node tempNode = head; while (null != tempNode.next) &#123; tempNode = tempNode.next;//寻找尾结点 &#125; //此时tempNode是尾结点 node.next = tempNode.next;//null，把node定义为尾结点，后继指针为null tempNode.next = node;//当前尾结点的后继指针指向node &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
