<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode Database做题笔记</title>
      <link href="/2019/08/05/Leetcode-Database/"/>
      <url>/2019/08/05/Leetcode-Database/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>不连接(即用<code>,</code>在<code>from</code>中分隔两表)和内连接的区别，是不是都可以产生笛卡尔积？</li><li>连接时用的<code>on</code>和判断时用的<code>where</code>如何正确使用，同时使用时如何正确使用？<a href="#">详见183方法一</a></li><li>使用<code>group by</code>时，只要是<code>select</code>中非聚集函数的列，都要在 <code>group by</code>当中</li></ul><h2 id="181-Employees-Earning-More-Than-Their-Managers"><a href="#181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="181. Employees Earning More Than Their Managers"></a>181. Employees Earning More Than Their Managers</h2><p>来源：<a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a><br><strong>考察</strong>：同一个表内的信息对比，需要把一张表看作两张表分别对比条件进行查询，也就是从这个表里<strong>获取两次信息</strong>。可以用到内连接，也可以不用内连接直接查询。</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| Employee |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| Joe      |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>此处还要注意题目还要求<strong>最终输出结果</strong>的表头为Employee  </p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee <span class="comment">--更改字段名,as可缺省</span></span><br><span class="line"><span class="keyword">from</span> Employee e1, Employee e2</span><br><span class="line"><span class="keyword">where</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">and</span> e1.Salary &gt; e2.Salary;</span><br><span class="line"><span class="comment">--用时461 ms</span></span><br></pre></td></tr></table></figure><p>在<code>where</code>语句之前，产生的笛卡尔积，查询结果有4*4=16个</p><h4 id="方法二：内连接"><a href="#方法二：内连接" class="headerlink" title="方法二：内连接"></a>方法二：内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">inner</span> <span class="keyword">join</span> Employee e2</span><br><span class="line"><span class="keyword">on</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">and</span> e1.Salary &gt; e2.Salary;</span><br><span class="line"><span class="comment">--615 ms</span></span><br></pre></td></tr></table></figure><h4 id="方法三：子查询"><a href="#方法三：子查询" class="headerlink" title="方法三：子查询"></a>方法三：子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee e1</span><br><span class="line"><span class="keyword">where</span> Salary &gt; (<span class="keyword">select</span> Salary</span><br><span class="line">                <span class="keyword">from</span> Employee e2</span><br><span class="line">                <span class="keyword">where</span> e2.Id = e1.ManagerId);</span><br><span class="line"><span class="comment">--974 ms</span></span><br></pre></td></tr></table></figure><h2 id="183-Customers-Who-Never-Order"><a href="#183-Customers-Who-Never-Order" class="headerlink" title="183. Customers Who Never Order"></a>183. Customers Who Never Order</h2><p>来源：<a href="https://leetcode.com/problems/customers-who-never-order/description/" target="_blank" rel="noopener">https://leetcode.com/problems/customers-who-never-order/description/</a><br>考察：查找不存在的数据，连接用<code>is null</code>,子查询用<code>not in</code></p><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p>Customers 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| Id | Name  |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br></pre></td></tr></table></figure><p>Orders 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+------------+</span></span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+<span class="comment">----+------------+</span></span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+<span class="comment">----+------------+</span></span><br></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| Customers |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+<span class="comment">-----------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="方法一：左外连接"><a href="#方法一：左外连接" class="headerlink" title="方法一：左外连接"></a>方法一：左外连接</h4><p><span id="redirect"></span><br>要查询<code>Orders</code>表中不存在，但在<code>Customers</code>表中存在的<code>CustomerId</code>,把<code>Orders</code>放在左连接的右边，就可以查询出<code>Orders</code>中<code>CustomerId</code>为<code>null</code>的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.Name <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers c <span class="keyword">left</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">on</span> c.Id = o.CustomerId</span><br><span class="line"><span class="keyword">where</span> o.CustomerId <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="方法二：子查询"><a href="#方法二：子查询" class="headerlink" title="方法二：子查询"></a>方法二：子查询</h4><p>查询不存在的值，可以用<code>where</code>与<code>not in</code>结合的方法，利用子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> CustomerId <span class="keyword">from</span> Orders)</span><br></pre></td></tr></table></figure><h2 id="184-Department-Highest-Salary"><a href="#184-Department-Highest-Salary" class="headerlink" title="184. Department Highest Salary"></a>184. Department Highest Salary</h2><p>来源：<a href="https://leetcode.com/problems/department-highest-salary/description/" target="_blank" rel="noopener">https://leetcode.com/problems/department-highest-salary/description/</a><br>考察：使用<code>join</code>和<code>in</code>。<code>in</code>可以用于多个字段,子查询或临时表</p><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br></pre></td></tr></table></figure><p>Department 表包含公司所有部门的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+----------+</span></span><br><span class="line">| Id | Name     |</span><br><span class="line">+<span class="comment">----+----------+</span></span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+<span class="comment">----+----------+</span></span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------------+----------+--------+</span></span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+<span class="comment">------------+----------+--------+</span></span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+<span class="comment">------------+----------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>首先可以在<code>Employee</code>表中根据<code>DepartmentId</code>分组找到每组最高<code>Salary</code>所代表的信息，也就是先创建一个临时表，包含了部门员工的最大薪资：<br><strong>此处特别注意: <code>select</code>中非聚集函数的列，都要在 <code>group by</code> 中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br></pre></td></tr></table></figure><p>得出结果为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| DepartmentId | MAX(Salary) |</span><br><span class="line">|<span class="comment">--------------|-------------|</span></span><br><span class="line">| 1            | 90000       |</span><br><span class="line">| 2            | 80000       |</span><br></pre></td></tr></table></figure><p>然后，把表 <code>Employee</code> 和 <code>Department</code> 连接，再在这张临时表里用 <code>IN</code>语句查询部门名字和工资的关系。<strong>在<code>in</code>语句中可以同时使用多个字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name Department, e.Name Employee, Salary</span><br><span class="line"><span class="keyword">from</span> Department d <span class="keyword">join</span> Employee e <span class="keyword">on</span> d.Id = e.DepartmentId</span><br><span class="line"><span class="keyword">where</span> (e.DepartmentId, Salary) <span class="keyword">in</span> ( <span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line">                                    <span class="keyword">from</span> Employee</span><br><span class="line">                                    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔试题常用输入方法</title>
      <link href="/2019/07/30/scanner_input/"/>
      <url>/2019/07/30/scanner_input/</url>
      
        <content type="html"><![CDATA[<p>从三月份找实习开始，我才算是真正意识到自己有多菜。经历了数不清多少次的笔试，算法方面菜鸡也就算了，没想到几乎每次考试都会在输入方面卡壳半个小时左右。这次7.28号拼多多“学霸批”的笔试，也是在输入方面浪费了大量时间。为此，在这里总结一下笔试可能会用到的输入方法，吃一堑长一智。本文持续更新。</p><h2 id="类型一：多行输入，每行为一个数组，数字之间用空格隔开"><a href="#类型一：多行输入，每行为一个数组，数字之间用空格隔开" class="headerlink" title="类型一：多行输入，每行为一个数组，数字之间用空格隔开"></a>类型一：多行输入，每行为一个数组，数字之间用空格隔开</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String str1 = in.nextLine().toString();<span class="comment">//读取第一行</span></span><br><span class="line">String[] a = str1.split(<span class="string">" "</span>);<span class="comment">//按空格分开为字符串数组</span></span><br><span class="line"><span class="keyword">int</span>[] arrA = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//新建同大小的整型数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">  arrA[i] = Integer.parseInt(a[i]);<span class="comment">//字符串解析为十进制整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str2 = in.nextLine().toString();<span class="comment">//读取第二行，后面几行同理</span></span><br><span class="line">String[] b = str2.split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">int</span>[] arrB = <span class="keyword">new</span> <span class="keyword">int</span>[b.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrB.length; i++) &#123;</span><br><span class="line">  arrB[i] = Integer.parseInt(b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(arrA));<span class="comment">//显示数组</span></span><br><span class="line">System.out.println(Arrays.toString(arrB));</span><br></pre></td></tr></table></figure><h2 id="类型二：第一行一个整数，第二行一个数组"><a href="#类型二：第一行一个整数，第二行一个数组" class="headerlink" title="类型二：第一行一个整数，第二行一个数组"></a>类型二：第一行一个整数，第二行一个数组</h2><p>此类型的输入不区分各行，只判定第一个整数为数组大小，之后的整数为数组数据即可。也就是只按整型输入读取。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个整数(数组大小)，一个数组(空格或回车隔开)</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1 3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YJC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line"> <span class="keyword">int</span> m = in.nextInt();<span class="comment">//读取第一个整数，即数组大小</span></span><br><span class="line"> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[m];<span class="comment">//新建数组</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">   numbers[i] = in.nextInt();<span class="comment">//按整型输入读取</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> System.out.println(Arrays.toString(numbers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型三：输入多行整数用逗号隔开"><a href="#类型三：输入多行整数用逗号隔开" class="headerlink" title="类型三：输入多行整数用逗号隔开"></a>类型三：输入多行整数用逗号隔开</h2><p> 输入<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>,<span class="number">3</span>,<span class="number">55</span></span><br></pre></td></tr></table></figure></p><p> 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String[] line = in.nextLine().split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(line[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> b = Integer.parseInt(line[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> c = Integer.parseInt(line[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
            <tag> 输入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现单链表，实现链表的插入和删除</title>
      <link href="/2019/07/30/linkedList/"/>
      <url>/2019/07/30/linkedList/</url>
      
        <content type="html"><![CDATA[<p>创建自定义的类和构造方法来实现简单的单链表。将结点结构定义为私有内部类，在外部类中对链表结构进行初始化，包括头结点和初始大小。</p><p> 单链表操作原理不难，难点在于对链表进行插入和删除操作时，对于指针交换和分配的逻辑。</p><p>插入：找到要插入的位置 i 后，用新结点的后继指针替换 i 的后继指针，再将 i 的后继指针指向该新结点。</p><p>删除：将要删除位置的后继指针指向下下个元素。</p><p>整表创建：注意头插法和尾插法的逻辑，详见代码注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package SqList;</span><br><span class="line">/**</span><br><span class="line"> * 单链表</span><br><span class="line"> * @author YJC</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">//定义链表</span><br><span class="line">private int size;//链表节点的个数</span><br><span class="line">private Node head;//头节点</span><br><span class="line"></span><br><span class="line">public SingleLinkedList() &#123;</span><br><span class="line">size = 0;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链表的结点类</span><br><span class="line">private class Node&#123;</span><br><span class="line">private Object data;//每个节点的数据</span><br><span class="line">private Node next;//结点指向下一个节点的指针</span><br><span class="line"></span><br><span class="line">public Node(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找链表中第i个元素,返回给e</span><br><span class="line">public Node find(int i,Object e) &#123;</span><br><span class="line">Node current = head;</span><br><span class="line">int temp = 1;</span><br><span class="line">while(temp&lt;i) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">e = current;</span><br><span class="line">return (Node) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在第i个位置前插入新的元素e</span><br><span class="line">public Object insert(int i,Object e) &#123;</span><br><span class="line">Node newNode = new Node(e);//新建一个节点</span><br><span class="line">Node current = head;</span><br><span class="line">int temp = 1;</span><br><span class="line">while(temp&lt;i) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">newNode.next = current.next;</span><br><span class="line">current.next = newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除第i个结点</span><br><span class="line">public void delete(int i) &#123;</span><br><span class="line">int temp = 1;</span><br><span class="line">Node current = head;</span><br><span class="line">while(temp&lt;i &amp;&amp; current!=null) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">current.next = current.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//单链表的整表创建,头插法  加入n个元素到单链表</span><br><span class="line">public void createAtHead(int n) &#123;</span><br><span class="line">Node head = null;//头结点指向null，即建立一个带头结点的单链表</span><br><span class="line">for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">Node node = new Node(Math.random()*100+1);//生成1-100的数字</span><br><span class="line">node.next = head;</span><br><span class="line">head = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void createAtTail(int n) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">Node node = new Node(Math.random() * 100 + 1);// 生成1-100的数字</span><br><span class="line"></span><br><span class="line">Node tempNode = head;</span><br><span class="line">while (null != tempNode.next) &#123;</span><br><span class="line">tempNode = tempNode.next;//寻找尾结点</span><br><span class="line">&#125;</span><br><span class="line">//此时tempNode是尾结点</span><br><span class="line">node.next = tempNode.next;//null，把node定义为尾结点，后继指针为null</span><br><span class="line">tempNode.next = node;//当前尾结点的后继指针指向node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/24/hello-world/"/>
      <url>/2019/07/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
