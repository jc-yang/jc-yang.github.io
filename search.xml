<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式，字符串拼接性能，设计购物车，KMP</title>
      <link href="/2019/08/16/TODO/"/>
      <url>/2019/08/16/TODO/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="字符串拼接性能"><a href="#字符串拼接性能" class="headerlink" title="字符串拼接性能"></a>字符串拼接性能</h2><p><a href="https://blog.csdn.net/KimSoft/article/details/3353849" target="_blank" rel="noopener">https://blog.csdn.net/KimSoft/article/details/3353849</a><br><a href="https://blog.csdn.net/flashdelover/article/details/50249701" target="_blank" rel="noopener">https://blog.csdn.net/flashdelover/article/details/50249701</a></p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h2 id="HashMap内部结构，调用put方法时如何实现"><a href="#HashMap内部结构，调用put方法时如何实现" class="headerlink" title="HashMap内部结构，调用put方法时如何实现"></a>HashMap内部结构，调用put方法时如何实现</h2><h2 id="HashSet是如何保证元素不重复的"><a href="#HashSet是如何保证元素不重复的" class="headerlink" title="HashSet是如何保证元素不重复的"></a>HashSet是如何保证元素不重复的</h2><h2 id="MySQL中插入一千万条数据如何是实现"><a href="#MySQL中插入一千万条数据如何是实现" class="headerlink" title="MySQL中插入一千万条数据如何是实现"></a>MySQL中插入一千万条数据如何是实现</h2><h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><h2 id="数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？"><a href="#数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？"></a>数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</h2><h2 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="HashMap-HashTable-ConcurrentHashMap"><a href="#HashMap-HashTable-ConcurrentHashMap" class="headerlink" title="HashMap, HashTable, ConcurrentHashMap"></a>HashMap, HashTable, ConcurrentHashMap</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>有三个比较容易混淆的概念：</p><p>Java内存模型（Java Memory Model（JMM））<br>JVM内存结构（JVM内存分区）<br>Java对象结构</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h2 id="NIO，AIO"><a href="#NIO，AIO" class="headerlink" title="NIO，AIO"></a>NIO，AIO</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏掉的筷子长度(只出现一次的数字)</title>
      <link href="/2019/08/16/Huawei/"/>
      <url>/2019/08/16/Huawei/</url>
      
        <content type="html"><![CDATA[<p>昨天华为的一面题目，没想到竟然挂在了一个这么简单的题目上：</p><blockquote><p>小明是个马大哈，某天他到超市买了若干双筷子（n &lt; 20），筷子的长度不尽相同，他把全部筷子都放在购物袋里面拿回家，路上不小心漏了一根，请你用程序帮他找出是漏掉的筷子是多长的。</p></blockquote><p>题目看了半天，搞不懂输入输出应该是什么，问面试官输入只是一个n吗，回答说对的，你可以自己给筷子编号（wtf ？？）， 硬着头皮用n新建了一个空数组，然后暴力循环了两遍找里面单个的值。做完后心里想，既然已经知道了数组中每个筷子的长度，那我不就已经知道是掉了拿一根了嘛（真是想太多。。）面试官看了后说我的时间 复杂度太大，可以考虑换个数据结构。然后我就想到了键值对的Map， 面试官说你照着这个思路写一下，继续做的时候又陷入了怎么初始化数据的怪圈。。。</p><p>总体来说面试体验很差，一是题目没有明确输入与输出应该是什么，最起码有个案例也行啊。二是我经验不足，思考不够全面，被一道题卡在输入和数据初始化上不知道是我的问题还是我的问题，哎不说了，解题！</p><p>今天一起实习的小伙伴告诉我说其实就是类似找重复或者不重复的数，异或就可以实现。上网找了一下题目，果然有明确的输入和输出(我哭了，有这两句话我早就写出来了。。。)：</p><blockquote><p>输入：  剩下的筷子数组，如：1, 2, 3, 2, 1, 3, 2<br>返回值：漏掉的筷子长度，如上述输入返回：2（当输入的筷子数据异常时返回-1，如：找不到漏掉的筷子）</p></blockquote><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>也就是我在面试的时候答出来的，循环两遍查找有无重复的值，若有重复值，则跳出小循环，判断下一个数是否在后面的数里面有重复。方法过于笨拙，就不贴代码了吧。嵌套循环，时间复杂度为O(n<sup>2</sup>)</p><h2 id="异或法"><a href="#异或法" class="headerlink" title="异或法"></a>异或法</h2><p>先说一下异或的主要性质，在去重和找重方面经常应用：  </p><blockquote><p>0 ^ a = a;<br>a ^ a = 0;<br>去重：把所有的</p></blockquote><p>下面是我写的代码，迭代器一次循环，时间复杂度为O(n)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find1</span><span class="params">(<span class="keyword">int</span>[] chopsticks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(chopsticks.length &gt;=<span class="number">39</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> chopLen:chopsticks) &#123;</span><br><span class="line">result ^= chopLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] chopsticks = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(find1(chopsticks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为4</p><h2 id="Map遍历法"><a href="#Map遍历法" class="headerlink" title="Map遍历法"></a>Map遍历法</h2><p>考虑面试官提示的key-value存储形式，当时卡在了map初始化上，还得多加练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map解法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find2</span><span class="params">(<span class="keyword">int</span>[] chopsticks)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Key为筷子长度，Value为个数</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="comment">//初始化map，昨天也在这里卡住了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:chopsticks) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(i)) &#123;</span><br><span class="line">map.put(i, map.get(i)+<span class="number">1</span>);<span class="comment">//有重复则数值+1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//遍历map，重点掌握</span></span><br><span class="line"><span class="keyword">for</span>(Integer i:map.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] chopsticks = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(find1(chopsticks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为4</p><h3 id="遍历Map的几种方法"><a href="#遍历Map的几种方法" class="headerlink" title="遍历Map的几种方法"></a>遍历Map的几种方法</h3><p>代码过程中发现忘记了怎么遍历map。。。赶紧复习一波<br>参考博客<br><a href="https://www.cnblogs.com/bingyimeiling/p/10741761.html" target="_blank" rel="noopener">https://www.cnblogs.com/bingyimeiling/p/10741761.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 循环遍历Map的4中方法</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. entrySet遍历，在键和值都需要时使用（最常用）</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + entry.getKey() + <span class="string">", value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过keySet或values来实现遍历,性能略低于第一种方式</span></span><br><span class="line"><span class="comment">// 遍历map中的键</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历map中的值</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用Iterator遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; entry = it.next();</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + entry.getKey() + <span class="string">", value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. java8 Lambda</span></span><br><span class="line"><span class="comment">// java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，</span></span><br><span class="line"><span class="comment">// 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式</span></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果只是获取key，或者value，推荐使用keySet或者values方式；</p></li><li><p>如果同时需要key和value推荐使用entrySet；</p></li><li><p>如果需要在遍历过程中删除元素推荐使用Iterator；</p></li><li><p>如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2019/08/15/Sort/"/>
      <url>/2019/08/15/Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot;<span class="comment">//枢纽，左边的值都比它小，右边的值都比它大,是下标</span></span><br><span class="line"><span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">pivot = partition(L,low,high);<span class="comment">//算出pivot，将L[low]...L[high]一分为二</span></span><br><span class="line">quickSort(L, low, pivot-<span class="number">1</span>);<span class="comment">//低子表排序</span></span><br><span class="line">quickSort(L, pivot+<span class="number">1</span>, high);<span class="comment">//高子表排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = L[low];<span class="comment">//将数组的第一个记录作为pivot</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;key) &#123;<span class="comment">//右边大，不交换，high-1下一个high</span></span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp1 = L[high];</span><br><span class="line">L[high] = L[low];</span><br><span class="line">L[low] = temp1;<span class="comment">//右边比key小，则交换</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;key) &#123;<span class="comment">//左边小，不交换，low++下一个low</span></span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp2 = L[high];</span><br><span class="line">L[high] = L[low];</span><br><span class="line">L[low] = temp2;<span class="comment">//左边比key大，则交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L[i] &lt; L[i - <span class="number">1</span>]) &#123;<span class="comment">// 在L[0]...L[i-1]的有序数列中找到合适的位置插入L[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = L[i];<span class="comment">// 哨兵保存L[i]的值</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i-<span class="number">1</span>; j&gt;=<span class="number">0</span> &amp;&amp; L[j]&gt;temp; j--) &#123;</span><br><span class="line">L[j + <span class="number">1</span>] = L[j];<span class="comment">// 记录后移,把比a[i]大的数据向后移动</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">L[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = i;<span class="comment">//初始为同一位置，如果i+1比i大则min仍然为i.循环进入i+1，min也为i+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;L.length;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(L[j]&lt;L[min])</span><br><span class="line">min = j;<span class="comment">//找到i后面的数据的最小值，下标给min</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i!=min) &#123;<span class="comment">//比较的是下标</span></span><br><span class="line"><span class="keyword">int</span> temp = L[i];</span><br><span class="line">L[i] = L[min];</span><br><span class="line">L[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化冒泡排序，对有序的数列不再进行判断，设置flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length-<span class="number">1</span> &amp;&amp; flag;i++) &#123;<span class="comment">//flag为false则说明没有发生交换，退出循环；若为true则说明发生了交换，仍需进一步判断排序</span></span><br><span class="line">flag = <span class="keyword">false</span>;<span class="comment">//初始为false，没有数据交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L.length-<span class="number">1</span>;j&gt;i;j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(L[j-<span class="number">1</span>]&gt;L[j]) &#123;<span class="comment">//交换</span></span><br><span class="line"><span class="keyword">int</span> temp = L[j];</span><br><span class="line">L[j] = L[j-<span class="number">1</span>];</span><br><span class="line">L[j-<span class="number">1</span>] = temp;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="多线程懒汉式"><a href="#多线程懒汉式" class="headerlink" title="多线程懒汉式"></a>多线程懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 的必要性：new 对象的时候分为三个步骤,请求对象空间，对象初始化，指针指向对象。volatile保证了不发生指令重排，避免在if判断时，double check多线程出错</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP语法, EL, JSTL, JSON，Ajax辨析</title>
      <link href="/2019/08/12/json-ajax-jstl-el/"/>
      <url>/2019/08/12/json-ajax-jstl-el/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对前端了解不多，在Web开发的学习中，时不时会遇到各种各样的前端语法的困扰，多种相似的表达式混用难免蛋疼。虽说已有各种框架解决了对这些前端脚本的解析，但本文旨在列举和梳理其中的知识体系，以免再混淆。</p><h2 id="JSP语法与JSP脚本"><a href="#JSP语法与JSP脚本" class="headerlink" title="JSP语法与JSP脚本"></a>JSP语法与JSP脚本</h2><p>此处参考了博客<a href="https://segmentfault.com/a/1190000013152739#articleHeader5" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013152739#articleHeader5</a></p><p>JSP(Java Server Page), Java服务器界面，是一种特殊的简化的Servlet，主要特点是JSP中java代码可以和页面html代码组合使用。此处不细讲其工作原理和内容。本文主要关注其语法与脚本书写。</p><h3 id="JSP初印象"><a href="#JSP初印象" class="headerlink" title="JSP初印象"></a>JSP初印象</h3><p> 在最简单的Web开发中，IDE初始生成的JSP页面index.jsp,再页面中使用Java输出Hello World如下：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">   pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"ISO-8859-1"</span>&gt;</span><br><span class="line">  &lt;title&gt;Insert title here&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="built_in">String</span> s = <span class="string">"HelloWorld"</span>;<span class="comment">//此处为Java代码</span></span><br><span class="line">out.println(s);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h3><p> 从上面代码看到，JSP中包含了HTML代码和Java代码</p><h4 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h4><p>JSP中的Java代码就是JSP脚本，必须有<code>&lt;% %&gt;</code>括起来，否则jsp会将其解析为HTML代码，出现解析偏差或出错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="built_in">String</span> s = <span class="string">"HelloWorld"</span>;<span class="comment">//此处为Java代码</span></span><br><span class="line">out.println(s);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h5 id="JSP内容输出表达式"><a href="#JSP内容输出表达式" class="headerlink" title="JSP内容输出表达式"></a>JSP内容输出表达式</h5><p><code>&lt;%= %&gt;</code> 用于在JSP中输出一个Java变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">User user = (User) session.getAttribute(<span class="string">"user"</span>);<span class="comment">//jsp的session内置对象</span></span><br><span class="line">%&gt;</span><br><span class="line">用户名&lt;%=user.getUsername() %&gt;&lt;br/&gt;</span><br><span class="line">年龄&lt;%=user.getAge() %&gt;&lt;br/&gt;</span><br><span class="line">性别&lt;%=user.getGender() %&gt;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">....</span></span><br></pre></td></tr></table></figure><h5 id="JSP内容定义表达式"><a href="#JSP内容定义表达式" class="headerlink" title="JSP内容定义表达式"></a>JSP内容定义表达式</h5><p><code>&lt;%! %&gt;</code>    JSP定义表达式，用于成员变量的定义，在Java代码块里的是局部变量。<strong>但已经没人用了</strong></p><h4 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h4><p><code>&lt;%--  --%&gt;</code> 不起任何实际作用</p><p>还可以注释 &lt;% %&gt;</p><p>在java代码中依然可以使用java支持的注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h4><p>JSP用于声明JSP页面的相关属性，语法为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@指令  属性名=<span class="string">"值"</span>  %&gt;</span><br></pre></td></tr></table></figure><p>如在JSP初印象中，制定了JSP的语言，文档类型，编码类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">   pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br></pre></td></tr></table></figure><p>JSP指令还可用于在jsp中引入java类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page <span class="keyword">import</span>=<span class="string">"java.util.Random"</span>%&gt;</span><br><span class="line">&lt;%@page <span class="keyword">import</span>=<span class="string">"java.util.Random,java.text.*"</span>%&gt;</span><br></pre></td></tr></table></figure><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language）表达式语言，是为了使JSP写起来更加简单。不属于编程语言。用于查找作用域中的数据，然后对它们执行一些简单的操作，用于对jsp标签的属性赋值</p><blockquote><p>在MVC模式中, JSP只充当视图，视图的任务就是显示响应，不需要在JSP中做任何关于程序控制和业务逻辑的事情。所以在JSP页面中应该尽可能少的、或者是完全不出现Java代码。来自<a href="https://baike.baidu.com/item/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/1190845?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote><h3 id="EL能干什么"><a href="#EL能干什么" class="headerlink" title="EL能干什么"></a>EL能干什么</h3><p>可以从域对象（request, session, application, pageContext等）中取得数据。<br> 无需导包，<strong>可直接在JSP中使用</strong>。</p><h3 id="EL表达式语法结构"><a href="#EL表达式语法结构" class="headerlink" title="EL表达式语法结构"></a>EL表达式语法结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;expression&#125;</span><br><span class="line">$&#123;requestScope.key&#125;</span><br><span class="line">$&#123;pageContextScope.key&#125;</span><br><span class="line">$&#123;sessionScope.key&#125;</span><br><span class="line">$&#123;applicationScope.key&#125;</span><br><span class="line">$&#123;key&#125; &lt;%--如果不指定域，那么会依次从域中搜索--%&gt;</span><br></pre></td></tr></table></figure><h3 id="EL举例"><a href="#EL举例" class="headerlink" title="EL举例"></a>EL举例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&#123;username&#125; 取得request里面名字为username的属性值（如果不存在返回空字符串）</span><br><span class="line">$&#123;user.username&#125;</span><br><span class="line">$&#123;list[index]&#125;</span><br><span class="line">$&#123;map.key&#125;</span><br><span class="line">$&#123;pageContext.request.contextPath&#125;</span><br><span class="line"></span><br><span class="line">$&#123;<span class="number">10</span>+<span class="number">89</span>&#125; 支持放置表达式运算</span><br><span class="line">$&#123;age&gt;<span class="number">10</span>&#125;</span><br><span class="line">$&#123;empty user&#125; 是否是<span class="literal">null</span>对象</span><br></pre></td></tr></table></figure><p>运算符号最好在{}内部实现，比如${a.count*b.price},而不能写成${a.count}<br>*<br>${b.price}</p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>此处参考了博客<a href="https://blog.csdn.net/qq_42350238/article/details/88994988" target="_blank" rel="noopener">https://blog.csdn.net/qq_42350238/article/details/88994988</a></p><p>JSTL（JavaServer Pages Standard Tag Library，JSP标准标签库)是一个不断完善的开源的JSP标签库,通常与EL表达式合作实现JSP页面的编写，让JSP写起来更加简单，优雅。可以让JSP页面在不写java代码的情况下实现取数据。</p><p>jstl是一个标签库，什么是标签库？可以只用一些自定义有自定义功能的标签。</p><p>其实EL+JSTL标签比java代码好用，就前端来说，而且它可以直接操作json类型，完美适应。</p><h3 id="JSTL的引入"><a href="#JSTL的引入" class="headerlink" title="JSTL的引入"></a>JSTL的引入</h3><p>下载地址<br>    <a href="http://tomcat.apache.org/taglibs/standard/" target="_blank" rel="noopener">http://tomcat.apache.org/taglibs/standard/</a></p><p>要使用jstl提供的标签，要先引入JSTL对应的标签库taglib</p><p>如何引入jstl标签库：(利用JSP指令的语法)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span> prefix=<span class="string">"fmt"</span> %&gt;</span><br></pre></td></tr></table></figure><p>就可以引入对应想要的标签库，其中</p><ul><li>uri：JSP标签的命名空间</li><li>prefix：命名空间的前缀(简称)</li></ul><h3 id="JSTL的使用-常用标签举例"><a href="#JSTL的使用-常用标签举例" class="headerlink" title="JSTL的使用(常用标签举例)"></a>JSTL的使用(常用标签举例)</h3><h4 id="跟数据存储相关：-set-out-remove"><a href="#跟数据存储相关：-set-out-remove" class="headerlink" title="跟数据存储相关： set, out, remove"></a>跟数据存储相关： set, out, remove</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:set</span> <span class="attr">var</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"123"</span> <span class="attr">scope</span>=<span class="string">"request"</span>&gt;</span><span class="tag">&lt;/<span class="name">c:set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">//<span class="attr">request.setAttribute</span>("<span class="attr">username</span>", "<span class="attr">123</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">"$&#123;username &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">c:out</span>&gt;</span></span><br><span class="line">$&#123;username&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:remove</span> <span class="attr">var</span>=<span class="string">"username"</span> <span class="attr">scope</span>=<span class="string">"request"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">//<span class="attr">request.removeAttribute</span>("<span class="attr">username</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br></pre></td></tr></table></figure><h4 id="条件标签"><a href="#条件标签" class="headerlink" title="条件标签"></a>条件标签</h4><p>if 语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;age&gt;=19 &#125;"</span>&gt;</span><br><span class="line">&lt;font color=<span class="string">"green"</span>&gt;你是成年人&lt;<span class="regexp">/font&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure><p>if else 语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test=<span class="string">"$&#123;age&gt;=19 &#125;"</span>&gt;</span><br><span class="line">&lt;font color=<span class="string">"green"</span>&gt;你是成年人&lt;<span class="regexp">/font&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;</span><br><span class="line">&lt;font color=<span class="string">"red"</span>&gt;未成年&lt;<span class="regexp">/font&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>c:otherwise&gt;</span><br><span class="line">&lt;<span class="regexp">/c:choose&gt;</span></span><br></pre></td></tr></table></figure><h4 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;lists &#125;"</span> <span class="keyword">var</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">$&#123;user.username &#125;:$&#123;user.age &#125;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br><span class="line"><span class="regexp">&lt;c:forEach items="$&#123;map &#125;" var="kv"&gt;</span></span><br><span class="line"><span class="regexp">$&#123;kv.key &#125;:$&#123;kv.value &#125;&lt;br/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br><span class="line"><span class="regexp">（要给属性提供get方法）</span></span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON (JavaScript Object Notation, JS对象表达) 是一种轻量级的数据交换格式,采用完全独立于编程语言的文本格式来存储和表示数据. 详细介绍可参考<a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a></p><p>JSON只用于存储可被解析的数据，其本质是一个字符串</p><p>JSON出现之前，通常用XML来传递数据。XML也是一种<strong>纯文本格式，所以它适合在网络上交换数据</strong>，但由于XML规范繁琐复杂，  </p><p>格式非常简单，有两种结构。</p><h3 id="JSON两种结构"><a href="#JSON两种结构" class="headerlink" title="JSON两种结构"></a>JSON两种结构</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象结构以<code>{</code>大括号开始，以<code>}</code>大括号结束。内部由多个键值对构成，键值对之间由<code>,</code>分隔:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="attr">"gender"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">1.65</span>,</span><br><span class="line">  <span class="attr">"grade"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"middle-school"</span>: <span class="string">"\"W3C\" Middle School"</span>,</span><br><span class="line">  <span class="attr">"skills"</span>: [</span><br><span class="line">            <span class="string">"JavaScript"</span>,</span><br><span class="line">            <span class="string">"Java"</span>,</span><br><span class="line">            <span class="string">"Python"</span>,</span><br><span class="line">            <span class="string">"Lisp"</span></span><br><span class="line">            ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于一个JavaBean，对象中包含了一个</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组类型可以是对象类型，即元素是对象。由方括号<code>[ ]</code>规定。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">14</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小华"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">22</span>,  </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="JSON注意事项"><a href="#JSON注意事项" class="headerlink" title="JSON注意事项"></a>JSON注意事项</h3><ul><li><p>JSON规定字符集必须是UTF-8。</p></li><li><p>为了统一解析，JSON的字符串规定必须用双引号<code>&quot;&quot;</code>，Object的键也必须用双引号<code>&quot;&quot;</code>。</p></li></ul><p>此处参考了<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021554858080" target="_blank" rel="noopener">廖雪峰的官方网站对JS的讲解</a></p><h3 id="JSON字符串与JSON对象辨析"><a href="#JSON字符串与JSON对象辨析" class="headerlink" title="JSON字符串与JSON对象辨析"></a>JSON字符串与JSON对象辨析</h3><ul><li><p>字符串：指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’;</p></li><li><p>json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”;</p></li><li><p>json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” };</p></li></ul><p>此处参考了<a href="https://www.cnblogs.com/mcgrady/archive/2013/06/08/3127781.html" target="_blank" rel="noopener">mcgrady的博客</a></p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax, 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>最常用的应用就是在前端注册信息时，不刷新网页的情况下校验是否存在重复的用户名，或者校验输入的邮箱格式是否正确。</p><ul><li><p>作用：在不进行页面跳转或者页面刷新的情况下，向服务器发起请求，并取得服务器响应的数据。</p></li><li><p>应用领域：数据校验</p></li><li><p>优点： ①用户体验比较好(不需要页面跳转，速度快)    ②服务器压力比较小</p></li></ul><h3 id="jQuery发起Ajax请求"><a href="#jQuery发起Ajax请求" class="headerlink" title="jQuery发起Ajax请求"></a>jQuery发起Ajax请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">"xxxservlet"</span>,</span><br><span class="line">type:<span class="string">"post"</span>,</span><br><span class="line">data:&#123;</span><br><span class="line">key:value,</span><br><span class="line">key:value</span><br><span class="line">&#125;,</span><br><span class="line">dataType:<span class="string">"json"</span>,</span><br><span class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">msg.key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其他参数和用法<a href="http://api.jquery.com/jQuery.ajax/" target="_blank" rel="noopener">http://api.jquery.com/jQuery.ajax/</a></p><h3 id="JavaScript发起Ajax请求"><a href="#JavaScript发起Ajax请求" class="headerlink" title="JavaScript发起Ajax请求"></a>JavaScript发起Ajax请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"xxxservlet"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)&#123;</span><br><span class="line"><span class="comment">//成功后的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参数和用法<a href="http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
            <tag> Web </tag>
            
            <tag> EL </tag>
            
            <tag> JSTL </tag>
            
            <tag> Ajax </tag>
            
            <tag> JSON </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Database做题笔记</title>
      <link href="/2019/08/05/Leetcode-Database/"/>
      <url>/2019/08/05/Leetcode-Database/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><del>不连接</del>交叉连接(即用<code>,</code>在<code>from</code>中分隔两表)和内连接的区别，是不是都可以产生笛卡尔积？</li><li>连接时用的<code>on</code>和判断时用的<code>where</code>如何正确使用，同时使用时如何正确使用？<a href="#">详见183方法一</a></li><li>使用<code>group by</code>时，只要是<code>select</code>中非聚集函数的列，都要在 <code>group by</code>当中</li></ul><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><h3 id="1-交叉连接与隐式内连接的区别"><a href="#1-交叉连接与隐式内连接的区别" class="headerlink" title="1. 交叉连接与隐式内连接的区别"></a>1. 交叉连接与隐式内连接的区别</h3><p>个人理解是，没有<code>where</code>就是交叉连接，有<code>where</code>就是隐式内连接。产生的中间表均为笛卡尔积，区别在于隐式内连接会对产生的笛卡尔积通过where进行过滤得到结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>; <span class="comment">--交叉连接</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span>，表<span class="number">2</span></span><br></pre></td></tr></table></figure><p>隐式内连接不用<code>on</code>语句，而用<code>where</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 表<span class="number">1.</span>关系字段 = 表<span class="number">2.</span>关系字段 <span class="comment">--隐式内连接</span></span><br></pre></td></tr></table></figure><h3 id="2-on-where-having的正确使用"><a href="#2-on-where-having的正确使用" class="headerlink" title="2. on, where, having的正确使用"></a>2. <code>on</code>, <code>where</code>, <code>having</code>的正确使用</h3><p>此处参考了<a href="https://blog.csdn.net/u013468917/article/details/61933994" target="_blank" rel="noopener">古月慕南</a>和<a href="https://my.oschina.net/lsl1991/blog/1921676" target="_blank" rel="noopener">LYQ1990</a>的博客，个人理解是</p><ul><li><p><code>on</code>用于建立关联关系, <code>where</code>用于筛选关联关系。  </p></li><li><p><code>on</code>是用于生成临时表时使用的条件。在<strong>外连接</strong>中，不管<code>on</code>的条件是否为真，都会返回<code>left join</code>中的左表信息，或者<code>right join</code>中的右表信息。</p></li><li><p><code>where</code>是在临时表生成之后对该临时表过滤用的条件，过滤掉条件不为真的所有信息。</p></li><li><p>在<strong>内连接</strong>中，条件放在<code>on</code>和<code>where</code>没区别，返回的结果集是相同的。  </p></li><li><p>在优先级方面，on &gt; where &gt; 聚合函数 &gt; having:</p><blockquote><p>表关联生成临时表， <strong>on 条件生效</strong>（此时的临时表会因为left join或right join的特性而一定带有主表的记录，也就是主表的记录不会被 on 条件过滤掉） –&gt; 临时表生成完毕，<strong>where条件过滤临时表</strong>（where条件过滤时因为临时表已经生成完毕，因此不会再具有left join或right join的特性，也就是主表记录也会被where条件过滤掉） –&gt; 临时表过滤完毕，<strong>聚合函数进行运算</strong> –&gt; 聚合函数运算完毕，<strong>having生效对运算完毕的临时表进行过滤</strong> –&gt;最终的结果表</p></blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_27607579/article/details/83787592" target="_blank" rel="noopener">https://blog.csdn.net/qq_27607579/article/details/83787592</a></p></li></ul><ul><li><p><code>having</code>只与<code>group by</code> 连用， 即在分组过后过滤数据，条件中通常包含聚合函数。</p></li><li><p>① <code>WHERE</code> 子句用来筛选 <code>FROM</code> 子句中指定的操作所产生的行。<br>② <code>GROUP BY</code> 子句用来分组 <code>WHERE</code> 子句的输出。<br>③ <code>HAVING</code> 子句用来从分组的结果中筛选行。</p></li></ul><h2 id="181-Employees-Earning-More-Than-Their-Managers"><a href="#181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="181. Employees Earning More Than Their Managers"></a>181. Employees Earning More Than Their Managers</h2><p>来源：<a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a><br>考察：同一个表内的信息对比，需要把一张表看作两张表分别对比条件进行查询，也就是从这个表里<strong>获取两次信息</strong>。可以用到内连接，也可以不用内连接直接查询。</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| Employee |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| Joe      |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>此处还要注意题目还要求<strong>最终输出结果</strong>的<strong>表头</strong>为Employee  </p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee <span class="comment">--更改字段名,as可缺省</span></span><br><span class="line"><span class="keyword">from</span> Employee e1, Employee e2</span><br><span class="line"><span class="keyword">where</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">and</span> e1.Salary &gt; e2.Salary;</span><br><span class="line"><span class="comment">--用时461 ms</span></span><br></pre></td></tr></table></figure><p>在<code>where</code>语句之前，可以理解为<strong>交叉连接</strong>产生笛卡尔积，查询结果有4×4=16个。一般情况下不会使用交叉连接，这这业务需求比较少见。<br>在<strong>有</strong><code>where</code>语句时，语句表示一个<strong>隐性内连接</strong>，产生的中间表仍为笛卡尔积，结果用<code>where</code>语句过滤掉</p><h4 id="方法二：内连接"><a href="#方法二：内连接" class="headerlink" title="方法二：内连接"></a>方法二：内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">inner</span> <span class="keyword">join</span> Employee e2<span class="comment">--inner可缺省</span></span><br><span class="line"><span class="keyword">on</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">and</span> e1.Salary &gt; e2.Salary;</span><br><span class="line"><span class="comment">--615 ms</span></span><br></pre></td></tr></table></figure><h4 id="方法三：子查询"><a href="#方法三：子查询" class="headerlink" title="方法三：子查询"></a>方法三：子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee e1</span><br><span class="line"><span class="keyword">where</span> Salary &gt; (<span class="keyword">select</span> Salary</span><br><span class="line">                <span class="keyword">from</span> Employee e2</span><br><span class="line">                <span class="keyword">where</span> e2.Id = e1.ManagerId);</span><br><span class="line"><span class="comment">--974 ms</span></span><br></pre></td></tr></table></figure><h2 id="183-Customers-Who-Never-Order"><a href="#183-Customers-Who-Never-Order" class="headerlink" title="183. Customers Who Never Order"></a>183. Customers Who Never Order</h2><p>来源：<a href="https://leetcode.com/problems/customers-who-never-order/description/" target="_blank" rel="noopener">https://leetcode.com/problems/customers-who-never-order/description/</a><br>考察：查找不存在的数据，连接用<code>is null</code>,子查询用<code>not in</code></p><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p>Customers 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| Id | Name  |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br></pre></td></tr></table></figure><p>Orders 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+------------+</span></span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+<span class="comment">----+------------+</span></span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+<span class="comment">----+------------+</span></span><br></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| Customers |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+<span class="comment">-----------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="方法一：左外连接"><a href="#方法一：左外连接" class="headerlink" title="方法一：左外连接"></a>方法一：左外连接</h4><p><span id="redirect"></span><br>要查询<code>Orders</code>表中不存在，但在<code>Customers</code>表中存在的<code>CustomerId</code>,把<code>Orders</code>放在左连接的右边，就可以查询出<code>Orders</code>中<code>CustomerId</code>为<code>null</code>的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.Name <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers c <span class="keyword">left</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">on</span> c.Id = o.CustomerId</span><br><span class="line"><span class="keyword">where</span> o.CustomerId <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="方法二：子查询"><a href="#方法二：子查询" class="headerlink" title="方法二：子查询"></a>方法二：子查询</h4><p>查询不存在的值，可以用<code>where</code>与<code>not in</code>结合的方法，利用子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> CustomerId <span class="keyword">from</span> Orders)</span><br></pre></td></tr></table></figure><h2 id="184-Department-Highest-Salary"><a href="#184-Department-Highest-Salary" class="headerlink" title="184. Department Highest Salary"></a>184. Department Highest Salary</h2><p>来源：<a href="https://leetcode.com/problems/department-highest-salary/description/" target="_blank" rel="noopener">https://leetcode.com/problems/department-highest-salary/description/</a><br>考察：使用<code>join</code>和<code>in</code>。<code>in</code>可以用于多个字段,子查询或临时表</p><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br></pre></td></tr></table></figure><p>Department 表包含公司所有部门的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+----------+</span></span><br><span class="line">| Id | Name     |</span><br><span class="line">+<span class="comment">----+----------+</span></span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+<span class="comment">----+----------+</span></span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------------+----------+--------+</span></span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+<span class="comment">------------+----------+--------+</span></span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+<span class="comment">------------+----------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>首先可以在<code>Employee</code>表中根据<code>DepartmentId</code>分组找到每组最高<code>Salary</code>所代表的信息，也就是先创建一个临时表，包含了部门员工的最大薪资：<br><strong>此处特别注意: <code>select</code>中非聚集函数的列，都要在 <code>group by</code> 中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br></pre></td></tr></table></figure><p>得出结果为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| DepartmentId | MAX(Salary) |</span><br><span class="line">|<span class="comment">--------------|-------------|</span></span><br><span class="line">| 1            | 90000       |</span><br><span class="line">| 2            | 80000       |</span><br></pre></td></tr></table></figure><p>然后，把表 <code>Employee</code> 和 <code>Department</code> 连接，再在这张临时表里用 <code>IN</code>语句查询部门名字和工资的关系。<strong>在<code>in</code>语句中可以同时使用多个字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name Department, e.Name Employee, Salary</span><br><span class="line"><span class="keyword">from</span> Department d <span class="keyword">join</span> Employee e <span class="keyword">on</span> d.Id = e.DepartmentId</span><br><span class="line"><span class="keyword">where</span> (e.DepartmentId, Salary) <span class="keyword">in</span> ( <span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line">                                    <span class="keyword">from</span> Employee</span><br><span class="line">                                    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔试题常用输入方法</title>
      <link href="/2019/07/30/scanner_input/"/>
      <url>/2019/07/30/scanner_input/</url>
      
        <content type="html"><![CDATA[<p>从三月份找实习开始，我才算是真正意识到自己有多菜。经历了数不清多少次的笔试，算法方面菜鸡也就算了，没想到几乎每次考试都会在输入方面卡壳半个小时左右。这次7.28号拼多多“学霸批”的笔试，也是在输入方面浪费了大量时间。为此，在这里总结一下笔试可能会用到的输入方法，吃一堑长一智。本文持续更新。</p><h2 id="类型一：多行输入，每行为一个数组，数字之间用空格隔开"><a href="#类型一：多行输入，每行为一个数组，数字之间用空格隔开" class="headerlink" title="类型一：多行输入，每行为一个数组，数字之间用空格隔开"></a>类型一：多行输入，每行为一个数组，数字之间用空格隔开</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String str1 = in.nextLine().toString();<span class="comment">//读取第一行</span></span><br><span class="line">String[] a = str1.split(<span class="string">" "</span>);<span class="comment">//按空格分开为字符串数组</span></span><br><span class="line"><span class="keyword">int</span>[] arrA = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//新建同大小的整型数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">  arrA[i] = Integer.parseInt(a[i]);<span class="comment">//字符串解析为十进制整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str2 = in.nextLine().toString();<span class="comment">//读取第二行，后面几行同理</span></span><br><span class="line">String[] b = str2.split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">int</span>[] arrB = <span class="keyword">new</span> <span class="keyword">int</span>[b.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrB.length; i++) &#123;</span><br><span class="line">  arrB[i] = Integer.parseInt(b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(arrA));<span class="comment">//显示数组</span></span><br><span class="line">System.out.println(Arrays.toString(arrB));</span><br></pre></td></tr></table></figure><h2 id="类型二：第一行一个整数，第二行一个数组"><a href="#类型二：第一行一个整数，第二行一个数组" class="headerlink" title="类型二：第一行一个整数，第二行一个数组"></a>类型二：第一行一个整数，第二行一个数组</h2><p>此类型的输入不区分各行，只判定第一个整数为数组大小，之后的整数为数组数据即可。也就是只按整型输入读取。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个整数(数组大小)，一个数组(空格或回车隔开)</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1 3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YJC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line"> <span class="keyword">int</span> m = in.nextInt();<span class="comment">//读取第一个整数，即数组大小</span></span><br><span class="line"> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[m];<span class="comment">//新建数组</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">   numbers[i] = in.nextInt();<span class="comment">//按整型输入读取</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> System.out.println(Arrays.toString(numbers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型三：输入多行整数用逗号隔开"><a href="#类型三：输入多行整数用逗号隔开" class="headerlink" title="类型三：输入多行整数用逗号隔开"></a>类型三：输入多行整数用逗号隔开</h2><p> 输入<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>,<span class="number">3</span>,<span class="number">55</span></span><br></pre></td></tr></table></figure></p><p> 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String[] line = in.nextLine().split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(line[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> b = Integer.parseInt(line[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> c = Integer.parseInt(line[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现单链表，实现链表的插入和删除</title>
      <link href="/2019/07/30/linkedList/"/>
      <url>/2019/07/30/linkedList/</url>
      
        <content type="html"><![CDATA[<p>创建自定义的类和构造方法来实现简单的单链表。将结点结构定义为私有内部类，在外部类中对链表结构进行初始化，包括头结点和初始大小。</p><p> 单链表操作原理不难，难点在于对链表进行插入和删除操作时，对于指针交换和分配的逻辑。</p><p>插入：找到要插入的位置 i 后，用新结点的后继指针替换 i 的后继指针，再将 i 的后继指针指向该新结点。</p><p>删除：将要删除位置的后继指针指向下下个元素。</p><p>整表创建：注意头插法和尾插法的逻辑，详见代码注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package SqList;</span><br><span class="line">/**</span><br><span class="line"> * 单链表</span><br><span class="line"> * @author YJC</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">//定义链表</span><br><span class="line">private int size;//链表节点的个数</span><br><span class="line">private Node head;//头节点</span><br><span class="line"></span><br><span class="line">public SingleLinkedList() &#123;</span><br><span class="line">size = 0;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链表的结点类</span><br><span class="line">private class Node&#123;</span><br><span class="line">private Object data;//每个节点的数据</span><br><span class="line">private Node next;//结点指向下一个节点的指针</span><br><span class="line"></span><br><span class="line">public Node(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找链表中第i个元素,返回给e</span><br><span class="line">public Node find(int i,Object e) &#123;</span><br><span class="line">Node current = head;</span><br><span class="line">int temp = 1;</span><br><span class="line">while(temp&lt;i) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">e = current;</span><br><span class="line">return (Node) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在第i个位置前插入新的元素e</span><br><span class="line">public Object insert(int i,Object e) &#123;</span><br><span class="line">Node newNode = new Node(e);//新建一个节点</span><br><span class="line">Node current = head;</span><br><span class="line">int temp = 1;</span><br><span class="line">while(temp&lt;i) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">newNode.next = current.next;</span><br><span class="line">current.next = newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除第i个结点</span><br><span class="line">public void delete(int i) &#123;</span><br><span class="line">int temp = 1;</span><br><span class="line">Node current = head;</span><br><span class="line">while(temp&lt;i &amp;&amp; current!=null) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">current.next = current.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//单链表的整表创建,头插法  加入n个元素到单链表</span><br><span class="line">public void createAtHead(int n) &#123;</span><br><span class="line">Node head = null;//头结点指向null，即建立一个带头结点的单链表</span><br><span class="line">for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">Node node = new Node(Math.random()*100+1);//生成1-100的数字</span><br><span class="line">node.next = head;</span><br><span class="line">head = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void createAtTail(int n) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">Node node = new Node(Math.random() * 100 + 1);// 生成1-100的数字</span><br><span class="line"></span><br><span class="line">Node tempNode = head;</span><br><span class="line">while (null != tempNode.next) &#123;</span><br><span class="line">tempNode = tempNode.next;//寻找尾结点</span><br><span class="line">&#125;</span><br><span class="line">//此时tempNode是尾结点</span><br><span class="line">node.next = tempNode.next;//null，把node定义为尾结点，后继指针为null</span><br><span class="line">tempNode.next = node;//当前尾结点的后继指针指向node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/24/hello-world/"/>
      <url>/2019/07/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
