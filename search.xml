<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 2018面试高频算法</title>
      <link href="/2019/08/17/Leetcode2018Interview/"/>
      <url>/2019/08/17/Leetcode2018Interview/</url>
      
        <content type="html"><![CDATA[<h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136 只出现一次的数字"></a>136 只出现一次的数字</h3><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number/</a></p><h3 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169 求众数"></a>169 求众数</h3><p><a href="https://leetcode-cn.com/problems/two-sum/solution/qiu-zhong-shu-by-leetcode-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/qiu-zhong-shu-by-leetcode-2/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> major = nums.length/<span class="number">2</span>;<span class="comment">//求众数的条件</span></span><br></pre></td></tr></table></figure><h4 id="方法一-暴力搜索法"><a href="#方法一-暴力搜索法" class="headerlink" title="方法一 暴力搜索法"></a>方法一 暴力搜索法</h4><p> 不建议，时间复杂度O(n<sup>2</sup>),空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">             <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//注意初始化位置，每次检查完i位置的数后需要把count清0，重新计数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;<span class="comment">//count初始为0.所以仍从第一个位置开始</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-Map遍历法"><a href="#方法二-Map遍历法" class="headerlink" title="方法二 Map遍历法"></a>方法二 Map遍历法</h4><p><strong>Map常用于计数方面的算法</strong>，要牢记其<strong>初始化</strong>和<strong>遍历</strong>方法</p><p>时间复杂度O(n),空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> major = nums.length/<span class="number">2</span>;</span><br><span class="line">Map&lt;Integer,Integer&gt; map = numsMap(nums);<span class="comment">//map初始化</span></span><br><span class="line"><span class="keyword">if</span>(nums.length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Integer num:map.keySet()) &#123;<span class="comment">//Map遍历的方式之一</span></span><br><span class="line"><span class="keyword">if</span>(map.get(num)&gt;major) &#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer,Integer&gt; <span class="title">numsMap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;<span class="comment">//map初始化方法</span></span><br><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(num)) &#123;</span><br><span class="line">map.put(num, <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三-Boyer-Moore-投票算法"><a href="#方法三-Boyer-Moore-投票算法" class="headerlink" title="方法三 Boyer-Moore 投票算法"></a>方法三 Boyer-Moore 投票算法</h4><p>想法: 如果我们把众数记为 +1 ，把其他数记为 -1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。</p><p>（竖线用来划分每次计数器归零的情况）<br>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p><p>首先，下标为 0 的 7 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 5 是下一个众数的候选者。由于这个例子中 7 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， 7 仍然是剩下数字中的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数法，相同就+1；不同就-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorEle2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> candidate = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">candidate = num;</span><br><span class="line">&#125;</span><br><span class="line">count += (candidate == num)? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/</a><br>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>此处考虑到若从前往后 比较并排序需要把后面的数字挪动，为避免挪动增大空间复杂度，<strong>从后往前比较并填充</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = m+n-<span class="number">1</span>;<span class="comment">//合并后的最大下标</span></span><br><span class="line">m--;<span class="comment">//最大下标</span></span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">while</span>(n&gt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(m&gt;=<span class="number">0</span> &amp;&amp; nums1[m]&gt;nums2[n]) &#123;<span class="comment">//注意判断次序， 需要先判断m再判断数组</span></span><br><span class="line">nums1[p] = nums1[m];</span><br><span class="line">m--;</span><br><span class="line">p--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">nums1[p] = nums2[n];</span><br><span class="line">n--;</span><br><span class="line">p--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = m-- + --n;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">      nums1[p--] = m&gt;=<span class="number">0</span> &amp;&amp; nums1[m]&gt;nums2[n] ? nums1[m--]:nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h3><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/</a></p><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>双指针，一个从头开始，一个从尾开始</p><p>要求不区分大小写，就可以<strong>把字符串转为小写</strong><br>一定要区分好if和while</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">s = s.toLowerCase();<span class="comment">// 都转为小写</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (!isLawful(s.charAt(i))) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == s.length())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 空字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!isLawful(s.charAt(j))) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char ichar = s.charAt(i);//debug用</span></span><br><span class="line"><span class="comment">//char jchar = s.charAt(j);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLawful</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span> || c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a><br>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p>案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">返回 2.</span><br></pre></td></tr></table></figure><h4 id="方法一-Map存储遍历"><a href="#方法一-Map存储遍历" class="headerlink" title="方法一 Map存储遍历"></a>方法一 Map存储遍历</h4><p><strong>和出现次数有关的，不要犹豫，hash</strong></p><p>此类技术方法均可用map记录出现次数并遍历的方法。本题中不同点在于<strong>遍历时使用原先数组的索引</strong>进行遍历，因为题目要求的是找到<strong>第一个</strong>不重复的字符(value=1的key)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"><span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> ch:chars) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(ch)) &#123;</span><br><span class="line">map.put(ch,map.get(ch)+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">map.put(ch,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.get(chars[i]) == <span class="number">1</span>) <span class="keyword">return</span> i;<span class="comment">//利用字符 串索引</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方法二-桶存储"><a href="#方法二-桶存储" class="headerlink" title="方法二 桶存储"></a>方法二 桶存储</h4><p>当全是字母字符时，可以考虑用<strong>大小为26的整型数组</strong>存储每个字母的频次，索引为<code>ch-&#39;a&#39;</code>, 相当于一个简化的Map，<strong>原理与Map存储相同</strong></p><p>此处还应注意数组初始化大小之后，整型默认值均为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//初始化数组后默认值均为0,值为频次，索引为ch-'a'</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">  freq[s.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(freq[s.charAt(i)-<span class="string">'a'</span>]==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><p><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string/</a><br>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p>两个指针自增自减，相遇退出就完事了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>,j=s.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;i) &#123;</span><br><span class="line"><span class="keyword">char</span> temp = s[i];</span><br><span class="line">s[i++] = s[j];</span><br><span class="line">s[j--] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><p><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/</a></p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。要求使用空间复杂度为 O(1)的原地算法。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h4 id="方法一-暴力法"><a href="#方法一-暴力法" class="headerlink" title="方法一 暴力法"></a>方法一 暴力法</h4><p>理清旋转一次的算法，再重复k次即可。时间复杂度：O(n∗k) 。每个元素都被移动 1 步O(n)） k次O(k)</p><p>注意在变换时每次都是第j位和<strong>第 j-1 位的数值</strong>进行交换，并不是直接交换数值中的值，所以此处选取了prev来存储第j-1位的数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次循环变换一次,共变换k次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rotOnce(nums);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotOnce</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prev = nums[nums.length-<span class="number">1</span>];<span class="comment">//选取一个哨兵变量用于交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++) &#123;<span class="comment">//每次都是第j位和第j+1位的数值进行交换，j递增</span></span><br><span class="line"><span class="keyword">int</span> temp = nums[j];</span><br><span class="line">nums[j] = prev;</span><br><span class="line">prev = temp;<span class="comment">//prev每次都是nums[j]的前一个数值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-环状替换"><a href="#方法二-环状替换" class="headerlink" title="方法二 环状替换"></a>方法二 环状替换</h4><p>未看</p><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h3><p><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate/</a><br>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h4 id="方法一-Map存储法"><a href="#方法一-Map存储法" class="headerlink" title="方法一 Map存储法"></a>方法一 Map存储法</h4><p>刚开始想用数组桶的方法来存储每个数字出现的频次，但这种方法就<strong>忽略了负数</strong>的情况，造成了数组越界，故仍要用map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*考虑不足的代码，弃用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//没有考虑负数的情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">freq[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> f:freq) &#123;</span><br><span class="line"><span class="keyword">if</span>(f&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC代码如下,也是常规map，和出现次数有关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(num)) &#123;</span><br><span class="line">map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">map.put(num, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer num:map.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.get(num)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Boolean数组法"><a href="#Boolean数组法" class="headerlink" title="Boolean数组法"></a>Boolean数组法</h4><p>没看懂<br>TODO</p><h3 id="283-移动零-TODO"><a href="#283-移动零-TODO" class="headerlink" title="283. 移动零(TODO)"></a>283. 移动零(TODO)</h3><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes/</a><br>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p>说明: 必须在原数组上操作，不能拷贝额外的数组</p><p>参考别人的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：设置一个index，表示非0数的个数，循环遍历数组，</span></span><br><span class="line"><span class="comment">// 如果不是0，将非0值移动到第index位置,然后index + 1</span></span><br><span class="line"><span class="comment">//遍历结束之后，index值表示为非0的个数，再次遍历，从index位置后的位置此时都应该为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">           nums[index] = nums[i];</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">       nums[i] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后补零的操作其实可以替代为 <strong>直接交换nums[index]和nums[i]</strong>，因为index所经过的数组值都是非零项。如果是0，则index没有变，直接把i+1的非0值替换过来即可。 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = nums[index];</span><br><span class="line">nums[index] = nums[i];</span><br><span class="line">nums[i] = temp;</span><br><span class="line"></span><br><span class="line">index++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆、栈、队列"><a href="#堆、栈、队列" class="headerlink" title="堆、栈、队列"></a>堆、栈、队列</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="哈希与映射"><a href="#哈希与映射" class="headerlink" title="哈希与映射"></a>哈希与映射</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="排序与搜索"><a href="#排序与搜索" class="headerlink" title="排序与搜索"></a>排序与搜索</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h2 id="数学、位运算"><a href="#数学、位运算" class="headerlink" title="数学、位运算"></a>数学、位运算</h2><h1 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h2 id="堆、栈、队列-1"><a href="#堆、栈、队列-1" class="headerlink" title="堆、栈、队列"></a>堆、栈、队列</h2><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h2 id="哈希与映射-1"><a href="#哈希与映射-1" class="headerlink" title="哈希与映射"></a>哈希与映射</h2><h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><h2 id="排序与搜索-1"><a href="#排序与搜索-1" class="headerlink" title="排序与搜索"></a>排序与搜索</h2><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="图论-1"><a href="#图论-1" class="headerlink" title="图论"></a>图论</h2><h2 id="数学、位运算-1"><a href="#数学、位运算-1" class="headerlink" title="数学、位运算"></a>数学、位运算</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TODO:正则表达式，字符串拼接性能，设计购物车，KMP</title>
      <link href="/2019/08/16/TODO/"/>
      <url>/2019/08/16/TODO/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-tutorial.html</a></p><h2 id="字符串拼接性能-amp-StringBuffer与StringBuilder"><a href="#字符串拼接性能-amp-StringBuffer与StringBuilder" class="headerlink" title="字符串拼接性能 &amp; StringBuffer与StringBuilder"></a>字符串拼接性能 &amp; StringBuffer与StringBuilder</h2><p>参考博客<br><a href="https://www.cnblogs.com/lojun/articles/9664794.html" target="_blank" rel="noopener">https://www.cnblogs.com/lojun/articles/9664794.html</a><br><a href="https://blog.csdn.net/u014086926/article/details/52069074" target="_blank" rel="noopener">https://blog.csdn.net/u014086926/article/details/52069074</a></p><h3 id="字符串拼接性能"><a href="#字符串拼接性能" class="headerlink" title="字符串拼接性能"></a>字符串拼接性能</h3><p>在大部分情况下 StringBuilder &gt; StringBuffer &gt; String</p><p>相当于 不加锁&gt;加锁&gt;创建新对象</p><ul><li><p>用+的方式效率最差，concat由于是String内部方法，性能优于+的方式：str.concat(“new str”);</p></li><li><p>单线程下字符串的串联用StringBuilder的append，多线程下字符串的串联用StrngBuffer的append；</p></li><li><p>字符串的加号“+” 方法，虽然编译器对其做了优化，使用StringBuilder的append方法进行追加，但是每循环一次都会创建一个StringBuilder对象，且都会调用toString方法转换成字符串，所以开销很大</p></li><li><p>在<strong>编译阶段就能够确定的字符串常量</strong>，完全没有必要创建String或StringBuffer对象。直接使用字符串常量的”+”连接操作效率最高（如：String str = “a” + “b” + “c”;）</p></li></ul><p>举例说明：</p><p>单个String对象的字符串拼接在<strong>编译阶段</strong>被 JVM 解释成了StringBuilder虽然也被对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中，String 效率是远要比 StringBuffer 快的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This is only a” + “ simple” + “ test”;<span class="comment">//快</span></span><br><span class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuffer(“This is only a”).append(“ simple”).append(“ test”);<span class="comment">//慢</span></span><br></pre></td></tr></table></figure><p>原因是JVM将<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This is only a” + “ simple” + “test”;</span><br></pre></td></tr></table></figure></p><p>等同于了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String S1 = “This is only a simple test”;</span><br></pre></td></tr></table></figure><p>所以当然不需要太多的时间了。但如果字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String S2 = “This is only a”;</span><br><span class="line">String S3 = “ simple”;</span><br><span class="line">String S4 = “ test”;</span><br><span class="line">String S1 = S2 +S3 + S4;</span><br></pre></td></tr></table></figure><p>这时候 JVM 会规规矩矩的按照原来的方式去做，疯狂创建对象并连接。</p><h3 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h3><ul><li><p>String对象是不可变的，修改String时重新指向另一个对象，而非在原地址进行修改。String被<code>final</code>修饰，不可继承，实例化后不能被修改。其本质上是一个<code>final</code>修饰的字符数组char[]。<code>final</code>修饰的叫不可变类，一旦对象创建在内存中就不可变。String是线程安全的，因为string内部存储字符串的char数组以及和char数组相关的信息都是final的。</p></li><li><p>StringBuilder虽然也被<code>final</code>修饰，但其底层的char数组并非<code>final</code>(定义在其父类AbstractStringBuilder中)，是一个可以被修改的动态数组。所有方法没有被synchronized修饰，并<strong>非线程安全</strong>。</p></li><li><p>StringBuffer也被<code>final</code>修饰，但其<strong>线程安全</strong>，因为里面所有方法都被<code>synchronized</code>修饰。</p></li></ul><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://www.cnblogs.com/SYCstudio/p/7194315.html" target="_blank" rel="noopener">https://www.cnblogs.com/SYCstudio/p/7194315.html</a></p><h2 id="HashMap内部结构，调用put方法时如何实现，红黑树"><a href="#HashMap内部结构，调用put方法时如何实现，红黑树" class="headerlink" title="HashMap内部结构，调用put方法时如何实现，红黑树"></a>HashMap内部结构，调用put方法时如何实现，红黑树</h2><p>参考博客</p><p><a href="https://www.cnblogs.com/shipengzhi/articles/2087505.html" target="_blank" rel="noopener">https://www.cnblogs.com/shipengzhi/articles/2087505.html</a></p><p><a href="https://www.cnblogs.com/wang-meng/p/9b6c35c4b2ef7e5b398db9211733292d.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang-meng/p/9b6c35c4b2ef7e5b398db9211733292d.html</a></p><p><a href="https://blog.csdn.net/sinat_37906153/article/details/83004831" target="_blank" rel="noopener">https://blog.csdn.net/sinat_37906153/article/details/83004831</a></p><p><a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanblog/p/4441017.html</a></p><p><a href="https://blog.csdn.net/u013164931/article/details/81389314" target="_blank" rel="noopener">https://blog.csdn.net/u013164931/article/details/81389314</a></p><h3 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h3><p>在HashMap中 存储key-value时，所有的计算都是 基于Entry中 的key，没有考虑value，可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。存储形式仍然是Entry&lt;key,value&gt;.</p><h3 id="HashMap的规则"><a href="#HashMap的规则" class="headerlink" title="HashMap的规则"></a>HashMap的规则</h3><ul><li><p>HashMap中,键和值都可以为null(null键只能有一个)</p></li><li><p>HashMap 的初始长度为 16，且每次扩容都必须以 2 的倍数（2^n）扩充，这是由取模规则<code>hashCode &amp; (length - 1)</code>决定的。 加载因子默认为0.75，size超过capacity的0.75 倍便2倍扩充。</p></li><li><p>如果两个Entry的key的hashCode()返回值相同，那它们的存储位置相同(因为取模之后的值肯定相同啦)。如果这两个Entry的key通过equals比较返回true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将添加到Entry 链的头部。</p></li><li><p>jdk1.8：当hash冲突元素达到8个后将链表转换为红黑树，在元素个数小于 6 时还原成链表</p></li><li><p>jdk1.8：元素的hashCode() 在很多时候下低位是相同的，这将导致冲突（碰撞），因此 1.8 以后做了个移位操作：将元素的 hashCode() 和自己右移 16 位后的结果求异或。将 hashCode 的高位和低位混合起来，降低冲突概率。<br>我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算，简而言之就是尽量打乱hashCode的低16位，因为真正参与运算的还是低16位。</p></li></ul><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>对key取hash运算后，所得hashcode对数组大小<strong>取模</strong>，得到元素在数组中的位置(即下标)，若此位置已经有了其他元素，则将元素插入到<strong>链头</strong>；若没有元素则直接放到数组该位置上。</p><p>因为有了取模的运算，所以链表中的元素存在一起并不都是哈希冲突造成的。</p><p>此处的取模运算是<code>hashCode &amp; (length - 1)</code>，length为数组的capacity。利用位运算代替取模运算，可以大大提高程序的计算效率。位运算可以直接对内存数据进行操作，不需要转换成十进制，因此效率要高得多。</p><p>需要注意的是，只有在特定情况下，位运算才可以转换成取模运算（当 b = 2^n 时，a % b = a &amp; (b - 1) ）。也是因此，HashMap 才将初始长度设置为 16，且扩容只能是以 2 的倍数（2^n）扩容</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><h3 id="面试手写get与put方法"><a href="#面试手写get与put方法" class="headerlink" title="面试手写get与put方法"></a>面试手写get与put方法</h3><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="HashSet是如何保证元素不重复的"><a href="#HashSet是如何保证元素不重复的" class="headerlink" title="HashSet是如何保证元素不重复的"></a>HashSet是如何保证元素不重复的</h2><h2 id="MySQL中插入一千万条数据如何是实现，在一亿条账号中查找有没有你的账号，找到重复的账号"><a href="#MySQL中插入一千万条数据如何是实现，在一亿条账号中查找有没有你的账号，找到重复的账号" class="headerlink" title="MySQL中插入一千万条数据如何是实现，在一亿条账号中查找有没有你的账号，找到重复的账号"></a>MySQL中插入一千万条数据如何是实现，在一亿条账号中查找有没有你的账号，找到重复的账号</h2><h2 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h2><h2 id="数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？"><a href="#数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？"></a>数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</h2><h2 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h2><p><a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanblog/p/4441017.html</a></p><p>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同</p><p>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点</p><h2 id="迭代器，枚举"><a href="#迭代器，枚举" class="headerlink" title="迭代器，枚举"></a>迭代器，枚举</h2><h2 id="HashMap-HashTable-ConcurrentHashMap"><a href="#HashMap-HashTable-ConcurrentHashMap" class="headerlink" title="HashMap, HashTable, ConcurrentHashMap"></a>HashMap, HashTable, ConcurrentHashMap</h2><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h2 id="读写锁的优先级"><a href="#读写锁的优先级" class="headerlink" title="读写锁的优先级"></a>读写锁的优先级</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>有三个比较容易混淆的概念：</p><p>Java内存模型（Java Memory Model（JMM））<br>JVM内存结构（JVM内存分区）<br>Java对象结构</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h2 id="NIO，AIO，BIO-多路复用"><a href="#NIO，AIO，BIO-多路复用" class="headerlink" title="NIO，AIO，BIO,多路复用"></a>NIO，AIO，BIO,多路复用</h2><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><h2 id="死锁与解锁"><a href="#死锁与解锁" class="headerlink" title="死锁与解锁"></a>死锁与解锁</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-tutorial.html</a></p><h2 id="数据库的数据结构，索引"><a href="#数据库的数据结构，索引" class="headerlink" title="数据库的数据结构，索引"></a>数据库的数据结构，索引</h2><h2 id="transient与序列化"><a href="#transient与序列化" class="headerlink" title="transient与序列化"></a>transient与序列化</h2><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h2><h2 id="红黑树-b树-b-树-区别"><a href="#红黑树-b树-b-树-区别" class="headerlink" title="红黑树 b树 b+树 区别"></a>红黑树 b树 b+树 区别</h2><h2 id="cpu密集型-io密集型"><a href="#cpu密集型-io密集型" class="headerlink" title="cpu密集型 io密集型"></a>cpu密集型 io密集型</h2><h2 id="线程池设计-很详细"><a href="#线程池设计-很详细" class="headerlink" title="线程池设计(很详细)"></a>线程池设计(很详细)</h2><h2 id="链表按段翻转"><a href="#链表按段翻转" class="headerlink" title="链表按段翻转"></a>链表按段翻转</h2><h2 id="http-https"><a href="#http-https" class="headerlink" title="http https"></a>http https</h2><h2 id="一次http流程：网址到显示"><a href="#一次http流程：网址到显示" class="headerlink" title="一次http流程：网址到显示"></a>一次http流程：网址到显示</h2><h2 id="线程间通信-进程间通信"><a href="#线程间通信-进程间通信" class="headerlink" title="线程间通信,进程间通信"></a>线程间通信,进程间通信</h2><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>参考神书《Java并发编程的艺术》Page 22</p><ul><li><p>共享变量包括了堆内存中的实例域，静态域和数组元素，<strong>堆内存在线程之间共享</strong>。</p></li><li><p>局部变量，方法定义参数，异常处理参数<strong>不在线程之间共享</strong>， 不存在内存可见性，也不受内存模型影响。</p></li></ul><p>线程间的通信由Java内存模型JMM控制，线程间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本次内存中存储该线程用于读/写的共享变量的副本。每个线程不能访问其他线程的本地内存。本地内存是抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及硬件和编译器优化。</p><p>线程A、B之间通讯必须经过两个步骤<br>① 线程A把本地内存A中更新过的共享变量刷新到主内存；<br>② 线程B到主内存中读取线程A之前更新过的共享变量。</p><p><img src="/.com//imgs/TODO/JMM.png" alt="Java内存模型抽象示意图"></p><h2 id="手写工厂模式"><a href="#手写工厂模式" class="headerlink" title="手写工厂模式"></a>手写工厂模式</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏掉的筷子长度(只出现一次的数字)</title>
      <link href="/2019/08/16/Huawei/"/>
      <url>/2019/08/16/Huawei/</url>
      
        <content type="html"><![CDATA[<p>昨天华为的一面题目，没想到竟然挂在了一个这么简单的题目上：</p><blockquote><p>小明是个马大哈，某天他到超市买了若干双筷子（n &lt; 20），筷子的长度不尽相同，他把全部筷子都放在购物袋里面拿回家，路上不小心漏了一根，请你用程序帮他找出是漏掉的筷子是多长的。</p></blockquote><p>题目看了半天，搞不懂输入输出应该是什么，问面试官输入只是一个n吗，回答说对的，你可以自己给筷子编号（wtf ？？）， 硬着头皮用n新建了一个空数组，然后暴力循环了两遍找里面单个的值。做完后心里想，既然已经知道了数组中每个筷子的长度，那我不就已经知道是掉了拿一根了嘛（真是想太多。。）面试官看了后说我的时间 复杂度太大，可以考虑换个数据结构。然后我就想到了键值对的Map， 面试官说你照着这个思路写一下，继续做的时候又陷入了怎么初始化数据的怪圈。。。</p><p>总体来说面试体验很差，一是题目没有明确输入与输出应该是什么，最起码有个案例也行啊。二是我经验不足，思考不够全面，被一道题卡在输入和数据初始化上不知道是我的问题还是我的问题，哎不说了，解题！</p><p>今天一起实习的小伙伴告诉我说其实就是类似找重复或者不重复的数，异或就可以实现。上网找了一下题目，果然有明确的输入和输出(我哭了，有这两句话我早就写出来了。。。)：</p><blockquote><p>输入：  剩下的筷子数组，如：1, 2, 3, 2, 1, 3, 2<br>返回值：漏掉的筷子长度，如上述输入返回：2（当输入的筷子数据异常时返回-1，如：找不到漏掉的筷子）</p></blockquote><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>也就是我在面试的时候答出来的，循环两遍查找有无重复的值，若有重复值，则跳出小循环，判断下一个数是否在后面的数里面有重复。方法过于笨拙，就不贴代码了吧。嵌套循环，时间复杂度为O(n<sup>2</sup>)</p><h2 id="异或法"><a href="#异或法" class="headerlink" title="异或法"></a>异或法</h2><p>先说一下异或的主要性质，在去重和找重方面经常应用：  </p><blockquote><p>0 ^ a = a;<br>a ^ a = 0;<br>去重：把所有的</p></blockquote><p>下面是我写的代码，迭代器一次循环，时间复杂度为O(n)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find1</span><span class="params">(<span class="keyword">int</span>[] chopsticks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(chopsticks.length &gt;=<span class="number">39</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> chopLen:chopsticks) &#123;</span><br><span class="line">result ^= chopLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] chopsticks = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(find1(chopsticks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为4</p><h2 id="Map遍历法"><a href="#Map遍历法" class="headerlink" title="Map遍历法"></a>Map遍历法</h2><p>考虑面试官提示的key-value存储形式，当时卡在了map初始化上，还得多加练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map解法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find2</span><span class="params">(<span class="keyword">int</span>[] chopsticks)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Key为筷子长度，Value为个数</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="comment">//初始化map，昨天也在这里卡住了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:chopsticks) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(i)) &#123;</span><br><span class="line">map.put(i, map.get(i)+<span class="number">1</span>);<span class="comment">//有重复则数值+1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//遍历map，重点掌握</span></span><br><span class="line"><span class="keyword">for</span>(Integer i:map.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span>(map.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] chopsticks = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(find1(chopsticks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为4</p><h3 id="遍历Map的几种方法"><a href="#遍历Map的几种方法" class="headerlink" title="遍历Map的几种方法"></a>遍历Map的几种方法</h3><p>代码过程中发现忘记了怎么遍历map。。。赶紧复习一波<br>参考博客<br><a href="https://www.cnblogs.com/bingyimeiling/p/10741761.html" target="_blank" rel="noopener">https://www.cnblogs.com/bingyimeiling/p/10741761.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 循环遍历Map的4中方法</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. entrySet遍历，在键和值都需要时使用（最常用）</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + entry.getKey() + <span class="string">", value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过keySet或values来实现遍历,性能略低于第一种方式</span></span><br><span class="line"><span class="comment">// 遍历map中的键</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历map中的值</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用Iterator遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; entry = it.next();</span><br><span class="line">System.out.println(<span class="string">"key = "</span> + entry.getKey() + <span class="string">", value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. java8 Lambda</span></span><br><span class="line"><span class="comment">// java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，</span></span><br><span class="line"><span class="comment">// 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式</span></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果只是获取key，或者value，推荐使用keySet或者values方式；</p></li><li><p>如果同时需要key和value推荐使用entrySet；</p></li><li><p>如果需要在遍历过程中删除元素推荐使用Iterator；</p></li><li><p>如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2019/08/15/Sort/"/>
      <url>/2019/08/15/Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot;<span class="comment">//枢纽，左边的值都比它小，右边的值都比它大,是下标</span></span><br><span class="line"><span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">pivot = partition(L,low,high);<span class="comment">//算出pivot，将L[low]...L[high]一分为二</span></span><br><span class="line">quickSort(L, low, pivot-<span class="number">1</span>);<span class="comment">//低子表排序</span></span><br><span class="line">quickSort(L, pivot+<span class="number">1</span>, high);<span class="comment">//高子表排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = L[low];<span class="comment">//将数组的第一个记录作为pivot</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; L[high]&gt;key) &#123;<span class="comment">//右边大，不交换，high-1下一个high</span></span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp1 = L[high];</span><br><span class="line">L[high] = L[low];</span><br><span class="line">L[low] = temp1;<span class="comment">//右边比key小，则交换</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high &amp;&amp; L[low]&lt;key) &#123;<span class="comment">//左边小，不交换，low++下一个low</span></span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp2 = L[high];</span><br><span class="line">L[high] = L[low];</span><br><span class="line">L[low] = temp2;<span class="comment">//左边比key大，则交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L[i] &lt; L[i - <span class="number">1</span>]) &#123;<span class="comment">// 在L[0]...L[i-1]的有序数列中找到合适的位置插入L[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = L[i];<span class="comment">// 哨兵保存L[i]的值</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i-<span class="number">1</span>; j&gt;=<span class="number">0</span> &amp;&amp; L[j]&gt;temp; j--) &#123;</span><br><span class="line">L[j + <span class="number">1</span>] = L[j];<span class="comment">// 记录后移,把比a[i]大的数据向后移动</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">L[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = i;<span class="comment">//初始为同一位置，如果i+1比i大则min仍然为i.循环进入i+1，min也为i+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;L.length;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(L[j]&lt;L[min])</span><br><span class="line">min = j;<span class="comment">//找到i后面的数据的最小值，下标给min</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i!=min) &#123;<span class="comment">//比较的是下标</span></span><br><span class="line"><span class="keyword">int</span> temp = L[i];</span><br><span class="line">L[i] = L[min];</span><br><span class="line">L[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化冒泡排序，对有序的数列不再进行判断，设置flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length-<span class="number">1</span> &amp;&amp; flag;i++) &#123;<span class="comment">//flag为false则说明没有发生交换，退出循环；若为true则说明发生了交换，仍需进一步判断排序</span></span><br><span class="line">flag = <span class="keyword">false</span>;<span class="comment">//初始为false，没有数据交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=L.length-<span class="number">1</span>;j&gt;i;j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(L[j-<span class="number">1</span>]&gt;L[j]) &#123;<span class="comment">//交换</span></span><br><span class="line"><span class="keyword">int</span> temp = L[j];</span><br><span class="line">L[j] = L[j-<span class="number">1</span>];</span><br><span class="line">L[j-<span class="number">1</span>] = temp;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="多线程懒汉式"><a href="#多线程懒汉式" class="headerlink" title="多线程懒汉式"></a>多线程懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile 的必要性：new 对象的时候分为三个步骤,请求对象空间，对象初始化，指针指向对象。volatile保证了不发生指令重排，避免在if判断时，double check多线程出错</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP语法, EL, JSTL, JSON，Ajax辨析</title>
      <link href="/2019/08/12/json-ajax-jstl-el/"/>
      <url>/2019/08/12/json-ajax-jstl-el/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对前端了解不多，在Web开发的学习中，时不时会遇到各种各样的前端语法的困扰，多种相似的表达式混用难免蛋疼。虽说已有各种框架解决了对这些前端脚本的解析，但本文旨在列举和梳理其中的知识体系，以免再混淆。</p><h2 id="JSP语法与JSP脚本"><a href="#JSP语法与JSP脚本" class="headerlink" title="JSP语法与JSP脚本"></a>JSP语法与JSP脚本</h2><p>此处参考了博客<a href="https://segmentfault.com/a/1190000013152739#articleHeader5" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013152739#articleHeader5</a></p><p>JSP(Java Server Page), Java服务器界面，是一种特殊的简化的Servlet，主要特点是JSP中java代码可以和页面html代码组合使用。此处不细讲其工作原理和内容。本文主要关注其语法与脚本书写。</p><h3 id="JSP初印象"><a href="#JSP初印象" class="headerlink" title="JSP初印象"></a>JSP初印象</h3><p> 在最简单的Web开发中，IDE初始生成的JSP页面index.jsp,再页面中使用Java输出Hello World如下：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">   pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"ISO-8859-1"</span>&gt;</span><br><span class="line">  &lt;title&gt;Insert title here&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="built_in">String</span> s = <span class="string">"HelloWorld"</span>;<span class="comment">//此处为Java代码</span></span><br><span class="line">out.println(s);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h3><p> 从上面代码看到，JSP中包含了HTML代码和Java代码</p><h4 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h4><p>JSP中的Java代码就是JSP脚本，必须有<code>&lt;% %&gt;</code>括起来，否则jsp会将其解析为HTML代码，出现解析偏差或出错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="built_in">String</span> s = <span class="string">"HelloWorld"</span>;<span class="comment">//此处为Java代码</span></span><br><span class="line">out.println(s);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h5 id="JSP内容输出表达式"><a href="#JSP内容输出表达式" class="headerlink" title="JSP内容输出表达式"></a>JSP内容输出表达式</h5><p><code>&lt;%= %&gt;</code> 用于在JSP中输出一个Java变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">User user = (User) session.getAttribute(<span class="string">"user"</span>);<span class="comment">//jsp的session内置对象</span></span><br><span class="line">%&gt;</span><br><span class="line">用户名&lt;%=user.getUsername() %&gt;&lt;br/&gt;</span><br><span class="line">年龄&lt;%=user.getAge() %&gt;&lt;br/&gt;</span><br><span class="line">性别&lt;%=user.getGender() %&gt;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">....</span></span><br></pre></td></tr></table></figure><h5 id="JSP内容定义表达式"><a href="#JSP内容定义表达式" class="headerlink" title="JSP内容定义表达式"></a>JSP内容定义表达式</h5><p><code>&lt;%! %&gt;</code>    JSP定义表达式，用于成员变量的定义，在Java代码块里的是局部变量。<strong>但已经没人用了</strong></p><h4 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h4><p><code>&lt;%--  --%&gt;</code> 不起任何实际作用</p><p>还可以注释 &lt;% %&gt;</p><p>在java代码中依然可以使用java支持的注释:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h4><p>JSP用于声明JSP页面的相关属性，语法为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@指令  属性名=<span class="string">"值"</span>  %&gt;</span><br></pre></td></tr></table></figure><p>如在JSP初印象中，制定了JSP的语言，文档类型，编码类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=utf-8"</span></span><br><span class="line">   pageEncoding=<span class="string">"utf-8"</span>%&gt;</span><br></pre></td></tr></table></figure><p>JSP指令还可用于在jsp中引入java类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page <span class="keyword">import</span>=<span class="string">"java.util.Random"</span>%&gt;</span><br><span class="line">&lt;%@page <span class="keyword">import</span>=<span class="string">"java.util.Random,java.text.*"</span>%&gt;</span><br></pre></td></tr></table></figure><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language）表达式语言，是为了使JSP写起来更加简单。不属于编程语言。用于查找作用域中的数据，然后对它们执行一些简单的操作，用于对jsp标签的属性赋值</p><blockquote><p>在MVC模式中, JSP只充当视图，视图的任务就是显示响应，不需要在JSP中做任何关于程序控制和业务逻辑的事情。所以在JSP页面中应该尽可能少的、或者是完全不出现Java代码。来自<a href="https://baike.baidu.com/item/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/1190845?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote><h3 id="EL能干什么"><a href="#EL能干什么" class="headerlink" title="EL能干什么"></a>EL能干什么</h3><p>可以从域对象（request, session, application, pageContext等）中取得数据。<br> 无需导包，<strong>可直接在JSP中使用</strong>。</p><h3 id="EL表达式语法结构"><a href="#EL表达式语法结构" class="headerlink" title="EL表达式语法结构"></a>EL表达式语法结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;expression&#125;</span><br><span class="line">$&#123;requestScope.key&#125;</span><br><span class="line">$&#123;pageContextScope.key&#125;</span><br><span class="line">$&#123;sessionScope.key&#125;</span><br><span class="line">$&#123;applicationScope.key&#125;</span><br><span class="line">$&#123;key&#125; &lt;%--如果不指定域，那么会依次从域中搜索--%&gt;</span><br></pre></td></tr></table></figure><h3 id="EL举例"><a href="#EL举例" class="headerlink" title="EL举例"></a>EL举例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&#123;username&#125; 取得request里面名字为username的属性值（如果不存在返回空字符串）</span><br><span class="line">$&#123;user.username&#125;</span><br><span class="line">$&#123;list[index]&#125;</span><br><span class="line">$&#123;map.key&#125;</span><br><span class="line">$&#123;pageContext.request.contextPath&#125;</span><br><span class="line"></span><br><span class="line">$&#123;<span class="number">10</span>+<span class="number">89</span>&#125; 支持放置表达式运算</span><br><span class="line">$&#123;age&gt;<span class="number">10</span>&#125;</span><br><span class="line">$&#123;empty user&#125; 是否是<span class="literal">null</span>对象</span><br></pre></td></tr></table></figure><p>运算符号最好在{}内部实现，比如${a.count*b.price},而不能写成${a.count}<br>*<br>${b.price}</p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>此处参考了博客<a href="https://blog.csdn.net/qq_42350238/article/details/88994988" target="_blank" rel="noopener">https://blog.csdn.net/qq_42350238/article/details/88994988</a></p><p>JSTL（JavaServer Pages Standard Tag Library，JSP标准标签库)是一个不断完善的开源的JSP标签库,通常与EL表达式合作实现JSP页面的编写，让JSP写起来更加简单，优雅。可以让JSP页面在不写java代码的情况下实现取数据。</p><p>jstl是一个标签库，什么是标签库？可以只用一些自定义有自定义功能的标签。</p><p>其实EL+JSTL标签比java代码好用，就前端来说，而且它可以直接操作json类型，完美适应。</p><h3 id="JSTL的引入"><a href="#JSTL的引入" class="headerlink" title="JSTL的引入"></a>JSTL的引入</h3><p>下载地址<br>    <a href="http://tomcat.apache.org/taglibs/standard/" target="_blank" rel="noopener">http://tomcat.apache.org/taglibs/standard/</a></p><p>要使用jstl提供的标签，要先引入JSTL对应的标签库taglib</p><p>如何引入jstl标签库：(利用JSP指令的语法)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span> prefix=<span class="string">"fmt"</span> %&gt;</span><br></pre></td></tr></table></figure><p>就可以引入对应想要的标签库，其中</p><ul><li>uri：JSP标签的命名空间</li><li>prefix：命名空间的前缀(简称)</li></ul><h3 id="JSTL的使用-常用标签举例"><a href="#JSTL的使用-常用标签举例" class="headerlink" title="JSTL的使用(常用标签举例)"></a>JSTL的使用(常用标签举例)</h3><h4 id="跟数据存储相关：-set-out-remove"><a href="#跟数据存储相关：-set-out-remove" class="headerlink" title="跟数据存储相关： set, out, remove"></a>跟数据存储相关： set, out, remove</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:set</span> <span class="attr">var</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"123"</span> <span class="attr">scope</span>=<span class="string">"request"</span>&gt;</span><span class="tag">&lt;/<span class="name">c:set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">//<span class="attr">request.setAttribute</span>("<span class="attr">username</span>", "<span class="attr">123</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">"$&#123;username &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">c:out</span>&gt;</span></span><br><span class="line">$&#123;username&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:remove</span> <span class="attr">var</span>=<span class="string">"username"</span> <span class="attr">scope</span>=<span class="string">"request"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">//<span class="attr">request.removeAttribute</span>("<span class="attr">username</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br></pre></td></tr></table></figure><h4 id="条件标签"><a href="#条件标签" class="headerlink" title="条件标签"></a>条件标签</h4><p>if 语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;age&gt;=19 &#125;"</span>&gt;</span><br><span class="line">&lt;font color=<span class="string">"green"</span>&gt;你是成年人&lt;<span class="regexp">/font&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure><p>if else 语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test=<span class="string">"$&#123;age&gt;=19 &#125;"</span>&gt;</span><br><span class="line">&lt;font color=<span class="string">"green"</span>&gt;你是成年人&lt;<span class="regexp">/font&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;</span><br><span class="line">&lt;font color=<span class="string">"red"</span>&gt;未成年&lt;<span class="regexp">/font&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>c:otherwise&gt;</span><br><span class="line">&lt;<span class="regexp">/c:choose&gt;</span></span><br></pre></td></tr></table></figure><h4 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">"$&#123;lists &#125;"</span> <span class="keyword">var</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">$&#123;user.username &#125;:$&#123;user.age &#125;&lt;br/&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br><span class="line"><span class="regexp">&lt;c:forEach items="$&#123;map &#125;" var="kv"&gt;</span></span><br><span class="line"><span class="regexp">$&#123;kv.key &#125;:$&#123;kv.value &#125;&lt;br/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/c:forEach&gt;</span></span><br><span class="line"><span class="regexp">（要给属性提供get方法）</span></span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON (JavaScript Object Notation, JS对象表达) 是一种轻量级的数据交换格式,采用完全独立于编程语言的文本格式来存储和表示数据. 详细介绍可参考<a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a></p><p>JSON只用于存储可被解析的数据，其本质是一个字符串</p><p>JSON出现之前，通常用XML来传递数据。XML也是一种<strong>纯文本格式，所以它适合在网络上交换数据</strong>，但由于XML规范繁琐复杂，  </p><p>格式非常简单，有两种结构。</p><h3 id="JSON两种结构"><a href="#JSON两种结构" class="headerlink" title="JSON两种结构"></a>JSON两种结构</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象结构以<code>{</code>大括号开始，以<code>}</code>大括号结束。内部由多个键值对构成，键值对之间由<code>,</code>分隔:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="attr">"gender"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">1.65</span>,</span><br><span class="line">  <span class="attr">"grade"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"middle-school"</span>: <span class="string">"\"W3C\" Middle School"</span>,</span><br><span class="line">  <span class="attr">"skills"</span>: [</span><br><span class="line">            <span class="string">"JavaScript"</span>,</span><br><span class="line">            <span class="string">"Java"</span>,</span><br><span class="line">            <span class="string">"Python"</span>,</span><br><span class="line">            <span class="string">"Lisp"</span></span><br><span class="line">            ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于一个JavaBean，对象中包含了一个</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组类型可以是对象类型，即元素是对象。由方括号<code>[ ]</code>规定。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">14</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"小华"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">22</span>,  </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="JSON注意事项"><a href="#JSON注意事项" class="headerlink" title="JSON注意事项"></a>JSON注意事项</h3><ul><li><p>JSON规定字符集必须是UTF-8。</p></li><li><p>为了统一解析，JSON的字符串规定必须用双引号<code>&quot;&quot;</code>，Object的键也必须用双引号<code>&quot;&quot;</code>。</p></li></ul><p>此处参考了<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021554858080" target="_blank" rel="noopener">廖雪峰的官方网站对JS的讲解</a></p><h3 id="JSON字符串与JSON对象辨析"><a href="#JSON字符串与JSON对象辨析" class="headerlink" title="JSON字符串与JSON对象辨析"></a>JSON字符串与JSON对象辨析</h3><ul><li><p>字符串：指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’;</p></li><li><p>json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”;</p></li><li><p>json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” };</p></li></ul><p>此处参考了<a href="https://www.cnblogs.com/mcgrady/archive/2013/06/08/3127781.html" target="_blank" rel="noopener">mcgrady的博客</a></p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax, 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>最常用的应用就是在前端注册信息时，不刷新网页的情况下校验是否存在重复的用户名，或者校验输入的邮箱格式是否正确。</p><ul><li><p>作用：在不进行页面跳转或者页面刷新的情况下，向服务器发起请求，并取得服务器响应的数据。</p></li><li><p>应用领域：数据校验</p></li><li><p>优点： ①用户体验比较好(不需要页面跳转，速度快)    ②服务器压力比较小</p></li></ul><h3 id="jQuery发起Ajax请求"><a href="#jQuery发起Ajax请求" class="headerlink" title="jQuery发起Ajax请求"></a>jQuery发起Ajax请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">"xxxservlet"</span>,</span><br><span class="line">type:<span class="string">"post"</span>,</span><br><span class="line">data:&#123;</span><br><span class="line">key:value,</span><br><span class="line">key:value</span><br><span class="line">&#125;,</span><br><span class="line">dataType:<span class="string">"json"</span>,</span><br><span class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">msg.key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其他参数和用法<a href="http://api.jquery.com/jQuery.ajax/" target="_blank" rel="noopener">http://api.jquery.com/jQuery.ajax/</a></p><h3 id="JavaScript发起Ajax请求"><a href="#JavaScript发起Ajax请求" class="headerlink" title="JavaScript发起Ajax请求"></a>JavaScript发起Ajax请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"xxxservlet"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)&#123;</span><br><span class="line"><span class="comment">//成功后的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他参数和用法<a href="http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
            <tag> Web </tag>
            
            <tag> EL </tag>
            
            <tag> JSTL </tag>
            
            <tag> Ajax </tag>
            
            <tag> JSON </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Database做题笔记</title>
      <link href="/2019/08/05/Leetcode-Database/"/>
      <url>/2019/08/05/Leetcode-Database/</url>
      
        <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><del>不连接</del>交叉连接(即用<code>,</code>在<code>from</code>中分隔两表)和内连接的区别，是不是都可以产生笛卡尔积？</li><li>连接时用的<code>on</code>和判断时用的<code>where</code>如何正确使用，同时使用时如何正确使用？<a href="#">详见183方法一</a></li><li>使用<code>group by</code>时，只要是<code>select</code>中非聚集函数的列，都要在 <code>group by</code>当中</li></ul><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><h3 id="1-交叉连接与隐式内连接的区别"><a href="#1-交叉连接与隐式内连接的区别" class="headerlink" title="1. 交叉连接与隐式内连接的区别"></a>1. 交叉连接与隐式内连接的区别</h3><p>个人理解是，没有<code>where</code>就是交叉连接，有<code>where</code>就是隐式内连接。产生的中间表均为笛卡尔积，区别在于隐式内连接会对产生的笛卡尔积通过where进行过滤得到结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>; <span class="comment">--交叉连接</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span>，表<span class="number">2</span></span><br></pre></td></tr></table></figure><p>隐式内连接不用<code>on</code>语句，而用<code>where</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 表<span class="number">1.</span>关系字段 = 表<span class="number">2.</span>关系字段 <span class="comment">--隐式内连接</span></span><br></pre></td></tr></table></figure><h3 id="2-on-where-having的正确使用"><a href="#2-on-where-having的正确使用" class="headerlink" title="2. on, where, having的正确使用"></a>2. <code>on</code>, <code>where</code>, <code>having</code>的正确使用</h3><p>此处参考了<a href="https://blog.csdn.net/u013468917/article/details/61933994" target="_blank" rel="noopener">古月慕南</a>和<a href="https://my.oschina.net/lsl1991/blog/1921676" target="_blank" rel="noopener">LYQ1990</a>的博客，个人理解是</p><ul><li><p><code>on</code>用于建立关联关系, <code>where</code>用于筛选关联关系。  </p></li><li><p><code>on</code>是用于生成临时表时使用的条件。在<strong>外连接</strong>中，不管<code>on</code>的条件是否为真，都会返回<code>left join</code>中的左表信息，或者<code>right join</code>中的右表信息。</p></li><li><p><code>where</code>是在临时表生成之后对该临时表过滤用的条件，过滤掉条件不为真的所有信息。</p></li><li><p>在<strong>内连接</strong>中，条件放在<code>on</code>和<code>where</code>没区别，返回的结果集是相同的。  </p></li><li><p>在优先级方面，on &gt; where &gt; 聚合函数 &gt; having:</p><blockquote><p>表关联生成临时表， <strong>on 条件生效</strong>（此时的临时表会因为left join或right join的特性而一定带有主表的记录，也就是主表的记录不会被 on 条件过滤掉） –&gt; 临时表生成完毕，<strong>where条件过滤临时表</strong>（where条件过滤时因为临时表已经生成完毕，因此不会再具有left join或right join的特性，也就是主表记录也会被where条件过滤掉） –&gt; 临时表过滤完毕，<strong>聚合函数进行运算</strong> –&gt; 聚合函数运算完毕，<strong>having生效对运算完毕的临时表进行过滤</strong> –&gt;最终的结果表</p></blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_27607579/article/details/83787592" target="_blank" rel="noopener">https://blog.csdn.net/qq_27607579/article/details/83787592</a></p></li></ul><ul><li><p><code>having</code>只与<code>group by</code> 连用， 即在分组过后过滤数据，条件中通常包含聚合函数。</p></li><li><p>① <code>WHERE</code> 子句用来筛选 <code>FROM</code> 子句中指定的操作所产生的行。<br>② <code>GROUP BY</code> 子句用来分组 <code>WHERE</code> 子句的输出。<br>③ <code>HAVING</code> 子句用来从分组的结果中筛选行。</p></li></ul><h2 id="181-Employees-Earning-More-Than-Their-Managers"><a href="#181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="181. Employees Earning More Than Their Managers"></a>181. Employees Earning More Than Their Managers</h2><p>来源：<a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a><br>考察：同一个表内的信息对比，需要把一张表看作两张表分别对比条件进行查询，也就是从这个表里<strong>获取两次信息</strong>。可以用到内连接，也可以不用内连接直接查询。</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+<span class="comment">----+-------+--------+-----------+</span></span><br></pre></td></tr></table></figure><p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| Employee |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| Joe      |</span><br><span class="line">+<span class="comment">----------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>此处还要注意题目还要求<strong>最终输出结果</strong>的<strong>表头</strong>为Employee  </p><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee <span class="comment">--更改字段名,as可缺省</span></span><br><span class="line"><span class="keyword">from</span> Employee e1, Employee e2</span><br><span class="line"><span class="keyword">where</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">and</span> e1.Salary &gt; e2.Salary;</span><br><span class="line"><span class="comment">--用时461 ms</span></span><br></pre></td></tr></table></figure><p>在<code>where</code>语句之前，可以理解为<strong>交叉连接</strong>产生笛卡尔积，查询结果有4×4=16个。一般情况下不会使用交叉连接，这这业务需求比较少见。<br>在<strong>有</strong><code>where</code>语句时，语句表示一个<strong>隐性内连接</strong>，产生的中间表仍为笛卡尔积，结果用<code>where</code>语句过滤掉</p><h4 id="方法二：内连接"><a href="#方法二：内连接" class="headerlink" title="方法二：内连接"></a>方法二：内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">inner</span> <span class="keyword">join</span> Employee e2<span class="comment">--inner可缺省</span></span><br><span class="line"><span class="keyword">on</span> e1.ManagerId = e2.Id</span><br><span class="line"><span class="keyword">and</span> e1.Salary &gt; e2.Salary;</span><br><span class="line"><span class="comment">--615 ms</span></span><br></pre></td></tr></table></figure><h4 id="方法三：子查询"><a href="#方法三：子查询" class="headerlink" title="方法三：子查询"></a>方法三：子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee e1</span><br><span class="line"><span class="keyword">where</span> Salary &gt; (<span class="keyword">select</span> Salary</span><br><span class="line">                <span class="keyword">from</span> Employee e2</span><br><span class="line">                <span class="keyword">where</span> e2.Id = e1.ManagerId);</span><br><span class="line"><span class="comment">--974 ms</span></span><br></pre></td></tr></table></figure><h2 id="183-Customers-Who-Never-Order"><a href="#183-Customers-Who-Never-Order" class="headerlink" title="183. Customers Who Never Order"></a>183. Customers Who Never Order</h2><p>来源：<a href="https://leetcode.com/problems/customers-who-never-order/description/" target="_blank" rel="noopener">https://leetcode.com/problems/customers-who-never-order/description/</a><br>考察：查找不存在的数据，连接用<code>is null</code>,子查询用<code>not in</code></p><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p>Customers 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| Id | Name  |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+<span class="comment">----+-------+</span></span><br></pre></td></tr></table></figure><p>Orders 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+------------+</span></span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+<span class="comment">----+------------+</span></span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+<span class="comment">----+------------+</span></span><br></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| Customers |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+<span class="comment">-----------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="方法一：左外连接"><a href="#方法一：左外连接" class="headerlink" title="方法一：左外连接"></a>方法一：左外连接</h4><p><span id="redirect"></span><br>要查询<code>Orders</code>表中不存在，但在<code>Customers</code>表中存在的<code>CustomerId</code>,把<code>Orders</code>放在左连接的右边，就可以查询出<code>Orders</code>中<code>CustomerId</code>为<code>null</code>的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.Name <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers c <span class="keyword">left</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">on</span> c.Id = o.CustomerId</span><br><span class="line"><span class="keyword">where</span> o.CustomerId <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="方法二：子查询"><a href="#方法二：子查询" class="headerlink" title="方法二：子查询"></a>方法二：子查询</h4><p>查询不存在的值，可以用<code>where</code>与<code>not in</code>结合的方法，利用子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> CustomerId <span class="keyword">from</span> Orders)</span><br></pre></td></tr></table></figure><h2 id="184-Department-Highest-Salary"><a href="#184-Department-Highest-Salary" class="headerlink" title="184. Department Highest Salary"></a>184. Department Highest Salary</h2><p>来源：<a href="https://leetcode.com/problems/department-highest-salary/description/" target="_blank" rel="noopener">https://leetcode.com/problems/department-highest-salary/description/</a><br>考察：使用<code>join</code>和<code>in</code>。<code>in</code>可以用于多个字段,子查询或临时表</p><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+<span class="comment">----+-------+--------+--------------+</span></span><br></pre></td></tr></table></figure><p>Department 表包含公司所有部门的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+----------+</span></span><br><span class="line">| Id | Name     |</span><br><span class="line">+<span class="comment">----+----------+</span></span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+<span class="comment">----+----------+</span></span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------------+----------+--------+</span></span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+<span class="comment">------------+----------+--------+</span></span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+<span class="comment">------------+----------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>首先可以在<code>Employee</code>表中根据<code>DepartmentId</code>分组找到每组最高<code>Salary</code>所代表的信息，也就是先创建一个临时表，包含了部门员工的最大薪资：<br><strong>此处特别注意: <code>select</code>中非聚集函数的列，都要在 <code>group by</code> 中</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br></pre></td></tr></table></figure><p>得出结果为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| DepartmentId | MAX(Salary) |</span><br><span class="line">|<span class="comment">--------------|-------------|</span></span><br><span class="line">| 1            | 90000       |</span><br><span class="line">| 2            | 80000       |</span><br></pre></td></tr></table></figure><p>然后，把表 <code>Employee</code> 和 <code>Department</code> 连接，再在这张临时表里用 <code>IN</code>语句查询部门名字和工资的关系。<strong>在<code>in</code>语句中可以同时使用多个字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name Department, e.Name Employee, Salary</span><br><span class="line"><span class="keyword">from</span> Department d <span class="keyword">join</span> Employee e <span class="keyword">on</span> d.Id = e.DepartmentId</span><br><span class="line"><span class="keyword">where</span> (e.DepartmentId, Salary) <span class="keyword">in</span> ( <span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line">                                    <span class="keyword">from</span> Employee</span><br><span class="line">                                    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 笔试 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔试题常用输入方法</title>
      <link href="/2019/07/30/scanner_input/"/>
      <url>/2019/07/30/scanner_input/</url>
      
        <content type="html"><![CDATA[<p>从三月份找实习开始，我才算是真正意识到自己有多菜。经历了数不清多少次的笔试，算法方面菜鸡也就算了，没想到几乎每次考试都会在输入方面卡壳半个小时左右。这次7.28号拼多多“学霸批”的笔试，也是在输入方面浪费了大量时间。为此，在这里总结一下笔试可能会用到的输入方法，吃一堑长一智。本文持续更新。</p><h2 id="类型一：多行输入，每行为一个数组，数字之间用空格隔开"><a href="#类型一：多行输入，每行为一个数组，数字之间用空格隔开" class="headerlink" title="类型一：多行输入，每行为一个数组，数字之间用空格隔开"></a>类型一：多行输入，每行为一个数组，数字之间用空格隔开</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String str1 = in.nextLine().toString();<span class="comment">//读取第一行</span></span><br><span class="line">String[] a = str1.split(<span class="string">" "</span>);<span class="comment">//按空格分开为字符串数组</span></span><br><span class="line"><span class="keyword">int</span>[] arrA = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//新建同大小的整型数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">  arrA[i] = Integer.parseInt(a[i]);<span class="comment">//字符串解析为十进制整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String str2 = in.nextLine().toString();<span class="comment">//读取第二行，后面几行同理</span></span><br><span class="line">String[] b = str2.split(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">int</span>[] arrB = <span class="keyword">new</span> <span class="keyword">int</span>[b.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrB.length; i++) &#123;</span><br><span class="line">  arrB[i] = Integer.parseInt(b[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(arrA));<span class="comment">//显示数组</span></span><br><span class="line">System.out.println(Arrays.toString(arrB));</span><br></pre></td></tr></table></figure><h2 id="类型二：第一行一个整数，第二行一个数组"><a href="#类型二：第一行一个整数，第二行一个数组" class="headerlink" title="类型二：第一行一个整数，第二行一个数组"></a>类型二：第一行一个整数，第二行一个数组</h2><p>此类型的输入不区分各行，只判定第一个整数为数组大小，之后的整数为数组数据即可。也就是只按整型输入读取。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个整数(数组大小)，一个数组(空格或回车隔开)</span></span><br><span class="line"><span class="comment"> * 2</span></span><br><span class="line"><span class="comment"> * 1 3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YJC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line"> <span class="keyword">int</span> m = in.nextInt();<span class="comment">//读取第一个整数，即数组大小</span></span><br><span class="line"> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[m];<span class="comment">//新建数组</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">   numbers[i] = in.nextInt();<span class="comment">//按整型输入读取</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> System.out.println(Arrays.toString(numbers));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型三：输入多行整数用逗号隔开"><a href="#类型三：输入多行整数用逗号隔开" class="headerlink" title="类型三：输入多行整数用逗号隔开"></a>类型三：输入多行整数用逗号隔开</h2><p> 输入<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>,<span class="number">3</span>,<span class="number">55</span></span><br></pre></td></tr></table></figure></p><p> 代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String[] line = in.nextLine().split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(line[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> b = Integer.parseInt(line[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> c = Integer.parseInt(line[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 输入 </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现单链表，实现链表的插入和删除</title>
      <link href="/2019/07/30/linkedList/"/>
      <url>/2019/07/30/linkedList/</url>
      
        <content type="html"><![CDATA[<p>创建自定义的类和构造方法来实现简单的单链表。将结点结构定义为私有内部类，在外部类中对链表结构进行初始化，包括头结点和初始大小。</p><p> 单链表操作原理不难，难点在于对链表进行插入和删除操作时，对于指针交换和分配的逻辑。</p><p>插入：找到要插入的位置 i 后，用新结点的后继指针替换 i 的后继指针，再将 i 的后继指针指向该新结点。</p><p>删除：将要删除位置的后继指针指向下下个元素。</p><p>整表创建：注意头插法和尾插法的逻辑，详见代码注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package SqList;</span><br><span class="line">/**</span><br><span class="line"> * 单链表</span><br><span class="line"> * @author YJC</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">//定义链表</span><br><span class="line">private int size;//链表节点的个数</span><br><span class="line">private Node head;//头节点</span><br><span class="line"></span><br><span class="line">public SingleLinkedList() &#123;</span><br><span class="line">size = 0;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//链表的结点类</span><br><span class="line">private class Node&#123;</span><br><span class="line">private Object data;//每个节点的数据</span><br><span class="line">private Node next;//结点指向下一个节点的指针</span><br><span class="line"></span><br><span class="line">public Node(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找链表中第i个元素,返回给e</span><br><span class="line">public Node find(int i,Object e) &#123;</span><br><span class="line">Node current = head;</span><br><span class="line">int temp = 1;</span><br><span class="line">while(temp&lt;i) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">e = current;</span><br><span class="line">return (Node) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在第i个位置前插入新的元素e</span><br><span class="line">public Object insert(int i,Object e) &#123;</span><br><span class="line">Node newNode = new Node(e);//新建一个节点</span><br><span class="line">Node current = head;</span><br><span class="line">int temp = 1;</span><br><span class="line">while(temp&lt;i) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">newNode.next = current.next;</span><br><span class="line">current.next = newNode;</span><br><span class="line">return newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除第i个结点</span><br><span class="line">public void delete(int i) &#123;</span><br><span class="line">int temp = 1;</span><br><span class="line">Node current = head;</span><br><span class="line">while(temp&lt;i &amp;&amp; current!=null) &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">current.next = current.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//单链表的整表创建,头插法  加入n个元素到单链表</span><br><span class="line">public void createAtHead(int n) &#123;</span><br><span class="line">Node head = null;//头结点指向null，即建立一个带头结点的单链表</span><br><span class="line">for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">Node node = new Node(Math.random()*100+1);//生成1-100的数字</span><br><span class="line">node.next = head;</span><br><span class="line">head = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void createAtTail(int n) &#123;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">Node node = new Node(Math.random() * 100 + 1);// 生成1-100的数字</span><br><span class="line"></span><br><span class="line">Node tempNode = head;</span><br><span class="line">while (null != tempNode.next) &#123;</span><br><span class="line">tempNode = tempNode.next;//寻找尾结点</span><br><span class="line">&#125;</span><br><span class="line">//此时tempNode是尾结点</span><br><span class="line">node.next = tempNode.next;//null，把node定义为尾结点，后继指针为null</span><br><span class="line">tempNode.next = node;//当前尾结点的后继指针指向node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/24/hello-world/"/>
      <url>/2019/07/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
