<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Database做题笔记]]></title>
    <url>%2F2019%2F08%2F05%2FLeetcode-Database%2F</url>
    <content type="text"><![CDATA[TODO 不连接(即用,在from中分隔两表)和内连接的区别，是不是都可以产生笛卡尔积？ 连接时用的on和判断时用的where如何正确使用，同时使用时如何正确使用？详见183方法一 使用group by时，只要是select中非聚集函数的列，都要在 group by当中 181. Employees Earning More Than Their Managers来源：https://leetcode.com/problems/employees-earning-more-than-their-managers/description/考察：同一个表内的信息对比，需要把一张表看作两张表分别对比条件进行查询，也就是从这个表里获取两次信息。可以用到内连接，也可以不用内连接直接查询。 DescriptionEmployee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 12345+----------+| Employee |+----------+| Joe |+----------+ Solution此处还要注意题目还要求最终输出结果的表头为Employee 方法一：12345select e1.Name as Employee --更改字段名,as可缺省from Employee e1, Employee e2where e1.ManagerId = e2.Idand e1.Salary &gt; e2.Salary;--用时461 ms 在where语句之前，产生的笛卡尔积，查询结果有4*4=16个 方法二：内连接12345select e1.Name as Employeefrom Employee e1 inner join Employee e2on e1.ManagerId = e2.Idand e1.Salary &gt; e2.Salary;--615 ms 方法三：子查询123456select e1.Name as Employeefrom Employee e1where Salary &gt; (select Salary from Employee e2 where e2.Id = e1.ManagerId);--974 ms 183. Customers Who Never Order来源：https://leetcode.com/problems/customers-who-never-order/description/考察：查找不存在的数据，连接用is null,子查询用not in Description某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： 12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表： 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回： 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ Solution方法一：左外连接要查询Orders表中不存在，但在Customers表中存在的CustomerId,把Orders放在左连接的右边，就可以查询出Orders中CustomerId为null的数据 1234select c.Name as Customersfrom Customers c left join Orders oon c.Id = o.CustomerIdwhere o.CustomerId is null; 方法二：子查询查询不存在的值，可以用where与not in结合的方法，利用子查询 123select Name as Customersfrom Customerswhere Id not in (select CustomerId from Orders) 184. Department Highest Salary来源：https://leetcode.com/problems/department-highest-salary/description/考察：使用join和in。in可以用于多个字段,子查询或临时表 DescriptionEmployee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ Solution首先可以在Employee表中根据DepartmentId分组找到每组最高Salary所代表的信息，也就是先创建一个临时表，包含了部门员工的最大薪资：此处特别注意: select中非聚集函数的列，都要在 group by 中 123select DepartmentId, max(Salary)from Employeegroup by DepartmentId 得出结果为 1234| DepartmentId | MAX(Salary) ||--------------|-------------|| 1 | 90000 || 2 | 80000 | 然后，把表 Employee 和 Department 连接，再在这张临时表里用 IN语句查询部门名字和工资的关系。在in语句中可以同时使用多个字段 12345select d.Name Department, e.Name Employee, Salaryfrom Department d join Employee e on d.Id = e.DepartmentIdwhere (e.DepartmentId, Salary) in ( select DepartmentId, max(Salary) from Employee group by DepartmentId );]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>笔试</tag>
        <tag>面试</tag>
        <tag>数据库</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔试题常用输入方法]]></title>
    <url>%2F2019%2F07%2F30%2Fscanner_input%2F</url>
    <content type="text"><![CDATA[从三月份找实习开始，我才算是真正意识到自己有多菜。经历了数不清多少次的笔试，算法方面菜鸡也就算了，没想到几乎每次考试都会在输入方面卡壳半个小时左右。这次7.28号拼多多“学霸批”的笔试，也是在输入方面浪费了大量时间。为此，在这里总结一下笔试可能会用到的输入方法，吃一堑长一智。本文持续更新。 类型一：多行输入，每行为一个数组，数字之间用空格隔开 1234567891011121314151617Scanner in = new Scanner(System.in);String str1 = in.nextLine().toString();//读取第一行String[] a = str1.split(" ");//按空格分开为字符串数组int[] arrA = new int[a.length];//新建同大小的整型数组for (int i = 0; i &lt; arrA.length; i++) &#123; arrA[i] = Integer.parseInt(a[i]);//字符串解析为十进制整数&#125;String str2 = in.nextLine().toString();//读取第二行，后面几行同理String[] b = str2.split(" ");int[] arrB = new int[b.length];for (int i = 0; i &lt; arrB.length; i++) &#123; arrB[i] = Integer.parseInt(b[i]);&#125;System.out.println(Arrays.toString(arrA));//显示数组System.out.println(Arrays.toString(arrB)); 类型二：第一行一个整数，第二行一个数组此类型的输入不区分各行，只判定第一个整数为数组大小，之后的整数为数组数据即可。也就是只按整型输入读取。 1234567891011121314151617 /** * 输入一个整数(数组大小)，一个数组(空格或回车隔开) * 2 * 1 3 * @author YJC * */Scanner in = new Scanner(System.in);while(in.hasNext()) &#123; int m = in.nextInt();//读取第一个整数，即数组大小 int[] numbers = new int[m];//新建数组 for(int i=0;i&lt;m;i++) &#123; numbers[i] = in.nextInt();//按整型输入读取 &#125; System.out.println(Arrays.toString(numbers));&#125; 类型三：输入多行整数用逗号隔开 输入 120,3,55 代码如下 12345Scanner in = new Scanner(System.in);String[] line = in.nextLine().split(",");int a = Integer.parseInt(line[0]);int b = Integer.parseInt(line[1]);int c = Integer.parseInt(line[2]);]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>输入</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现单链表，实现链表的插入和删除]]></title>
    <url>%2F2019%2F07%2F30%2FlinkedList%2F</url>
    <content type="text"><![CDATA[创建自定义的类和构造方法来实现简单的单链表。将结点结构定义为私有内部类，在外部类中对链表结构进行初始化，包括头结点和初始大小。 单链表操作原理不难，难点在于对链表进行插入和删除操作时，对于指针交换和分配的逻辑。 插入：找到要插入的位置 i 后，用新结点的后继指针替换 i 的后继指针，再将 i 的后继指针指向该新结点。 删除：将要删除位置的后继指针指向下下个元素。 整表创建：注意头插法和尾插法的逻辑，详见代码注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package SqList;/** * 单链表 * @author YJC * */public class SingleLinkedList &#123; //定义链表 private int size;//链表节点的个数 private Node head;//头节点 public SingleLinkedList() &#123; size = 0; head = null; &#125; //链表的结点类 private class Node&#123; private Object data;//每个节点的数据 private Node next;//结点指向下一个节点的指针 public Node(Object data) &#123; this.data = data; &#125; &#125; //查找链表中第i个元素,返回给e public Node find(int i,Object e) &#123; Node current = head; int temp = 1; while(temp&lt;i) &#123; current = current.next; temp++; &#125; e = current; return (Node) e; &#125; //在第i个位置前插入新的元素e public Object insert(int i,Object e) &#123; Node newNode = new Node(e);//新建一个节点 Node current = head; int temp = 1; while(temp&lt;i) &#123; current = current.next; temp++; &#125; newNode.next = current.next; current.next = newNode; return newNode; &#125; //删除第i个结点 public void delete(int i) &#123; int temp = 1; Node current = head; while(temp&lt;i &amp;&amp; current!=null) &#123; current = current.next; temp++; &#125; current.next = current.next.next; &#125; //单链表的整表创建,头插法 加入n个元素到单链表 public void createAtHead(int n) &#123; Node head = null;//头结点指向null，即建立一个带头结点的单链表 for(int i=0;i&lt;n;i++) &#123; Node node = new Node(Math.random()*100+1);//生成1-100的数字 node.next = head; head = node; &#125; &#125; public void createAtTail(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; Node node = new Node(Math.random() * 100 + 1);// 生成1-100的数字 Node tempNode = head; while (null != tempNode.next) &#123; tempNode = tempNode.next;//寻找尾结点 &#125; //此时tempNode是尾结点 node.next = tempNode.next;//null，把node定义为尾结点，后继指针为null tempNode.next = node;//当前尾结点的后继指针指向node &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
